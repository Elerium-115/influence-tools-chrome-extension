const svgIconCommunityTools = `<svg class="e115-icon-community-tools" version="1.1" viewBox="0 0 1200 1200" xmlns="http://www.w3.org/2000/svg"><path d="m700.36 208.62c37.5 9.5859 72.898 24.438 105.38 43.699l131.9-95.5 105.54 105.54-95.5 131.9c19.262 32.477 34.102 67.875 43.688 105.38l160.75 25.738v149.25l-160.74 25.738c-9.5859 37.5-24.438 72.898-43.699 105.38l95.5 131.9-105.54 105.54-131.9-95.5c-32.477 19.262-67.875 34.102-105.38 43.688l-25.738 160.75h-149.25l-25.738-160.74c-37.5-9.5859-72.898-24.438-105.38-43.699l-131.9 95.5-105.54-105.54 95.5-131.9c-19.262-32.477-34.102-67.875-43.688-105.38l-160.75-25.738v-149.25l160.75-25.738c9.5859-37.5 24.426-72.898 43.688-105.38l-95.5-131.9 105.54-105.54 131.9 95.5c32.477-19.262 67.875-34.102 105.38-43.688l25.738-160.75h149.25zm-100.36 120.89c-149.39 0-270.49 121.1-270.49 270.49 0 67.926 25.051 130 66.398 177.51 27.125-86.938 108.24-150.07 204.1-150.07 95.875 0 176.99 63.125 204.1 150.07 41.352-47.5 66.398-109.59 66.398-177.51-0.023438-149.39-121.12-270.49-270.51-270.49zm0-35.625c-169.06 0-306.11 137.05-306.11 306.11s137.05 306.11 306.11 306.11 306.11-137.05 306.11-306.11-137.05-306.11-306.11-306.11zm0 103.31c-59.688 0-108.09 48.387-108.09 108.07s48.387 108.07 108.09 108.07c59.688 0 108.07-48.387 108.07-108.07s-48.375-108.07-108.07-108.07z" fill-rule="evenodd"/></svg>`;

// Source: icon in "Zoom to lot" button @ "Lot Info" hud-menu panel
const svgIconSearch = `<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>`;

// Source: https://www.iconfinder.com/icons/4763233/hierarchy_network_organization_sitemap_structure_icon
const svgIconProductionChains = `<svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><g><path d="M20,16.18V11H13V7.82a3,3,0,1,0-2,0V11H4v5.18a3,3,0,1,0,2,0V13h5v3.18a3,3,0,1,0,2,0V13h5v3.18a3,3,0,1,0,2,0Z"></path></g></svg>`;

// Source: https://www.iconfinder.com/icons/3302789/energy_geothermal_plant_power_steam_icon
const svgIconFactoryArrows = `<svg fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><g transform="translate(0 1024) scale(.1 -.1)"><path d="m6450 10229c-32-13-78-56-97-93-9-17-70-428-159-1077-79-578-144-1054-144-1059 0-7-883-10-2432-10-2344 0-2434-1-2473-19-46-21-79-54-94-94-8-19-11-366-11-1102v-1074l-916-6-41-27c-24-16-49-44-62-70l-21-44v-2702c0-2410 2-2707 15-2739 21-50 42-72 90-94 39-18 209-19 5015-19s4976 1 5015 19c48 22 69 44 90 94 13 32 15 329 15 2739v2702l-21 44c-13 26-38 54-62 70l-41 27-467 3-468 3-6 32c-3 18-140 1012-304 2210-283 2062-300 2180-324 2216-15 23-44 47-69 60-44 21-45 21-1024 20-624 0-988-4-1004-10zm1790-351c0-2 16-118 35-258s35-258 35-262c0-5-385-8-856-8h-856l6 28c3 15 20 134 37 265l32 237h784c430 0 783-1 783-2zm124-915c7-32 446-3237 446-3253 0-7-418-10-1355-10-745 0-1355 2-1355 4s101 741 225 1641c124 901 225 1639 225 1641s407 4 904 4h904l6-27zm-2370-1365c-3-18-63-451-133-963l-127-930-2167-3-2167-2v965 965h2299 2300l-5-32zm3884-4032 2-1769-287 6c-157 4-562 7-899 7h-612l-7 183c-3 100-5 526-3 947l3 765 258-250c142-137 273-258 290-267 76-41 188-9 232 66 29 50 34 130 10 175-21 41-848 842-897 869-47 25-103 28-151 8-33-13-866-815-899-865-38-57-32-148 14-206 48-61 150-82 220-46 20 10 149 128 287 262s255 245 261 247c7 3 10-339 10-1035 0-683 4-1051 10-1075 14-50 55-97 105-119 37-17 73-19 431-19 215 0 668-3 1007-7l617-6v-539-538h-2290-2290v1677 1678l93-90c50-50 169-166 263-258 99-97 186-173 207-182 132-55 273 51 253 188-4 23-15 55-24 70-36 53-856 838-897 858-50 23-99 24-147 1-41-19-869-817-900-867-27-45-24-128 7-181 44-75 156-107 232-66 18 9 149 131 292 270l261 254v-1676-1676h-2290-2290v538 539l587 6c322 4 775 7 1005 7 450 0 461 1 516 53 60 56 57-17 62 1146l5 1063 265-256c146-140 279-263 297-271 17-8 50-15 72-15 129 0 214 123 170 248-14 41-865 867-914 888-44 18-96 18-140 0-48-20-885-835-907-884-50-108 23-238 141-250 88-8 101 1 383 274l263 256 3-734c2-403 0-828-3-944l-7-211-892-5c-490-3-894-3-898-1-10 5-11 3517-1 3526 3 4 2144 6 4757 5l4751-3 3-1769z"/><path d="m1817 7315c-128-45-162-200-66-296 53-53 106-62 342-57 163 3 198 6 230 22 144 71 125 292-30 335-58 16-429 13-476-4z"/><path d="m2827 7315c-75-26-118-86-119-165 0-91 53-159 142-179 58-14 382-14 440 0 89 20 142 88 142 179-1 82-52 148-130 170-57 15-428 12-475-5z"/><path d="m3837 7315c-75-26-118-86-119-165 0-94 54-160 150-181 33-6 127-10 245-7 220 3 249 12 301 86 69 97 15 239-102 272-57 15-428 12-475-5z"/><path d="m4847 7315c-75-26-118-86-119-165 0-91 53-159 142-179 60-14 376-14 441 0 183 39 191 299 11 349-57 15-428 12-475-5z"/></g></svg>`;

const eleriumApiUrl = 'https://elerium-influence-api.vercel.app';

const crewDataEndpoint = `${eleriumApiUrl}/crew-data`;
const crewmateVideosEndpoint = `${eleriumApiUrl}/data/crewmate-videos`;
const inventoriesDataEndpoint = `${eleriumApiUrl}/inventories-data`;
const pricesEndpoint = `${eleriumApiUrl}/data/prices`;
const shipDataEndpoint = `${eleriumApiUrl}/ship-data`;
const toolsEndpoint = `${eleriumApiUrl}/data/tools`;
const widgetsEndpoint = `${eleriumApiUrl}/data/widgets`;

const selectorHudMenu = '#hudMenu';
const selectorHudMenuPanel = '#hudMenuPanel';
const selectorTimeMenu = '#timeMenu';
const selectorTopMenu = '#topMenu';

/**
 * The default hud-menu item is "My Crews", because it always exists for a logged-in user:
 * - regardless of view (system view / asteroid view / surface view / ship view)
 * - regardless of page-load-screen being visible / dismissed (i.e. before / after clicking "Play")
 * - regardless of user actually having any crews
 */
const hudMenuItemLabelDefault = 'My Crews';

const hudMenuItemLabelMarketplace = 'Asteroid Markets';
const hudMenuItemLabelMyCrews = 'My Crews';
const hudMenuItemLabelLotInventory = 'Lot Inventory';
const hudMenuItemLabelResources = 'Resources';
const hudMenuItemLabelShipInventory = 'Ship Inventory';

const hudMenuItemLabelTools = 'Community Tools'; // to be injected

const extensionSettingsDefault = {
    autoHideMarketsWithoutPrice: true, // if true, product-specific markets without any supply / demand will be auto-hidden
    autoHideUsedDeposits: true, // if true, used deposits will be auto-hidden, and "My Deposits" will also be auto-expanded
    autoOpenInventoryPanel: true, // if true, the "Lot Inventory" or "Ship Inventory" panel will be auto-open
    autoOpenInventoryPanelBypassOtherPanels: false, // if true, and if "autoOpenInventoryPanel" also true, the inventory panel will be auto-open even if another panel is already open
    autoOpenResourcesPanel: true, // if true, the "Resources" panel will be auto-open for Extractors
    autoOpenResourcesPanelBypassOtherPanels: false, // if true, and if "autoOpenResourcesPanel" also true, the "Resources" panel will be auto-open even if another panel is already open
    crewmateColorIntensity: 4, // brightness amount (from 1 to 5) for the class-specific background color of crewmates
    extractionPercent: 100, // preferred extraction percentage
    highlightBlocklistedInventories: true, // if true, highlight inventories controlled by a blocklisted address, when selecting a target inventory
    highlightCrewsRationing: false, // if true, highlight the selected crew if rationing
    industryBuilderButton: true, // if true, inject a button in inventories re: "What can I make with these items?"
    inventoryItemNames: true, // if true, overlay names for inventory items
    locationController: true, // if true, inject details about the controller of the selected location (lot, building, landed ship, asteroid)
    onlyMyInventories: false, // if true, show only inventories controlled by the player, in the "Available Inventories" window
    onlyWarehouses: false, // if true, show only Warehouse inventories, in the "Available Inventories" window
    showShipStatsForMyCrews: true, // if true, show the loaded propellant percent in the "My Crews" list, for crews stationed on a ship
};

// Save default extension settings into local-storage, if needed
if (!localStorage.getItem('e115Settings')) {
    localStorage.setItem('e115Settings', JSON.stringify(extensionSettingsDefault));
}

const extensionSettings = JSON.parse(localStorage.getItem('e115Settings'));

const customBlacklistByAddressDefault = {};
const customNameByAddressDefault = {};

// Save default list of custom blacklist by address into local-storage, if needed
if (!localStorage.getItem('e115CustomBlacklistByAddress')) {
    localStorage.setItem('e115CustomBlacklistByAddress', JSON.stringify(customBlacklistByAddressDefault));
}

// Save default list of custom name by address into local-storage, if needed
if (!localStorage.getItem('e115CustomNameByAddress')) {
    localStorage.setItem('e115CustomNameByAddress', JSON.stringify(customNameByAddressDefault));
}

const selectedCrewData = {
    rationing: null,
};

const selectedLocationData = {
    buildingType: null,
    controllerData: null,
    idCurrent: null,
    idPrevious: null,
    isSystemView: false,
};

// Source: Influence SDK - "src/lib/building.js"
const BUILDING_TYPE = {
    EMPTY_LOT: 0,
    WAREHOUSE: 1,
    EXTRACTOR: 2,
    REFINERY: 3,
    BIOREACTOR: 4,
    FACTORY: 5,
    SHIPYARD: 6,
    SPACEPORT: 7,
    MARKETPLACE: 8,
    HABITAT: 9
};

// Source: Influence SDK - "src/lib/entity.js"
const ENTITY_IDS = {
    CREW: 1,
    CREWMATE: 2,
    ASTEROID: 3,
    LOT: 4,
    BUILDING: 5,
    SHIP: 6,
    DEPOSIT: 7,
    DELIVERY: 9,
    SPACE: 10
};

const YEAR_IN_SECONDS = 31536000; // 60 * 60 * 24 * 365
const MINUTE_IN_MILLISECONDS = 60000; // 60 * 1000

/**
 * Use properties which may have been recently added to default settings,
 * if they are not yet saved in local-storage. This also saves them into local-storage.
 */
for (const [settingKey, settingValue] of Object.entries(extensionSettingsDefault)) {
    if (typeof extensionSettings[settingKey] === 'undefined') {
        setExtensionSetting(settingKey, settingValue);
    }
}

let customBlacklistByAddress = JSON.parse(localStorage.getItem('e115CustomBlacklistByAddress'));
let customNameByAddress = JSON.parse(localStorage.getItem('e115CustomNameByAddress'));

/**
 * This will be populated via API call to "crewDataEndpoint"
 */
let crewDataByCrewId = {};

/**
 * This will be populated via API call to "crewmateVideosEndpoint"
 */
let crewmateVideos = null;

/**
 * This will be populated via API call to "inventoriesDataEndpoint"
 */
let inventoriesDataByLabelAndId = {
    5: {}, // buildings
    6: {}, // ships
};

/**
 * This will be populated via API call to "pricesEndpoint"
 */
let prices = null;

/**
 * This will be populated via API call to "shipDataEndpoint"
 */
let shipDataByShipId = {};

/**
 * This will be populated via API call to "toolsEndpoint"
 */
let tools = null;

/**
 * This will be populated via API call to "widgetsEndpoint"
 */
let widgets = null;

/**
 * This will contain a cloned DOM element for the hud-menu panel in an open state
 */
let hudMenuPanelOpenClone = null;

/**
 * This will contain a cloned DOM element (SVG) for the "arrow" next to a list-item in the hud-menu panel
 */
let hudMenuPanelListItemSvgClone = null;

/**
 * This will contain a cloned DOM element for a "close" button
 */
let closeButtonClone = null;

/**
 * This will be set to the class-list value (string, NOT DOMTokenList) of the hud-menu with a selected hud-menu item
 */
let hudMenuOpenClassListValue = null;

/**
 * This will be set to the class-list value (string, NOT DOMTokenList) of the hud-menu with NO selected hud-menu item
 */
let hudMenuClosedClassListValue = null;

/**
 * This will be set to the class-list value (string, NOT DOMTokenList) of a selected hud-menu item
 */
let hudMenuItemSelectedClassListValue = null;

/**
 * This will be set to the class-list value (string, NOT DOMTokenList) of an unselected hud-menu item
 */
let hudMenuItemUnselectedClassListValue = null;

/**
 * MAX extraction amount (i.e. 100% of deposit amount).
 * This will be updated during "injectAndApplyExtractionPercent".
 */
let extractionAmountMax = 0;

/**
 * This will be set to TRUE the FIRST time that the panel containing "Show Used Deposits"
 * becomes open during the periodical execution of "autoHideUsedDeposits". It will then be
 * reset to FALSE when that panel is closed, or no longer contains "Show Used Deposits".
 */
let isOpenPanelWithUsedDeposits = false;

let elLocationControllerWrapper = null;
let elLocationController = null;

let isUpdatingInventories = false;

function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function isArray(arr) {
    return Array.isArray(arr);
}

function isObject(obj) {
    return obj?.constructor === Object;
}

/**
 * Add or update an extension setting, and save the new value into local-storage
 */
function setExtensionSetting(settingKey, settingValue) {
    extensionSettings[settingKey] = settingValue;
    localStorage.setItem('e115Settings', JSON.stringify(extensionSettings));
}

function getReactPropsForEl(el) {
    const reactPropsKey = Object.keys(el).find(key => key.includes('__reactProps'));
    if (!reactPropsKey) {
        console.log(`%c--- [getReactPropsForEl] ERROR: reactPropsKey not found for el:`, 'background: red', el);
        return null;
    }
    return el[reactPropsKey];
}

function getReactFiberForEl(el) {
    const reactFiberKey = Object.keys(el).find(key => key.includes('__reactFiber'));
    if (!reactFiberKey) {
        console.log(`%c--- [getReactFiberForEl] ERROR: reactFiberKey not found for el:`, 'background: red', el);
        return null;
    }
    return el[reactFiberKey];
}

function getReactPropDataFromChildrenRecursive(propKey, reactChildren) {
    let propData = {
        foundOwnProperty: false,
        propValue: null,
    };
    // If "reactChildren" contains a single child, it will be an object (NOT an array)
    if (isObject(reactChildren)) {
        reactChildren = [reactChildren];
    }
    // If "children" is a terminal text node, it will be a string (NOT an object or array)
    if (!reactChildren || !isArray(reactChildren)) {
        return propData;
    }
    for (const child of reactChildren) {
        if (!child || !child.props) {
            // This child is explicitly undefined, or has no props => SKIP to the next child
            continue;
        }
        const props = child.props;
        if (props.hasOwnProperty(propKey)) {
            // Prop found in this child => STOP parsing remaining children
            propData.foundOwnProperty = true;
            propData.propValue = props[propKey];
            return propData;
        }
        // Prop not found in this child => recurse into its children, if any
        if (props.children) {
            propData = getReactPropDataFromChildrenRecursive(propKey, props.children);
        }
        if (propData.foundOwnProperty) {
            // Prop found among its children => STOP parsing remaining children
            return propData;
        }
    }
    return propData;
}

/**
 * Get the VISIBLE hud-menu.
 * 
 * NOTE: On page-load, there may be 2 hud-menus with the same ID,
 * until the player clicks "Play" (if logged-in) or "Explore World" (if not logged-in).
 */
function getElHudMenu() {
    // Select the VISIBLE hud-menu, if any
    const elHudMenu = [...document.querySelectorAll(selectorHudMenu)].find(el => el.offsetParent);
    if (!elHudMenu) {
        // console.log(`%c--- [getElHudMenu] ERROR: elHudMenu not found`, 'background: red');
    }
    return elHudMenu;
}

function getElHudMenuPanel() {
    const elHudMenuPanel = document.querySelector(selectorHudMenuPanel);
    if (!elHudMenuPanel) {
        // console.log(`%c--- [getElHudMenuPanel] ERROR: elHudMenuPanel not found`, 'background: red');
    }
    return elHudMenuPanel;
}

function getElHudMenuItemByLabel(label) {
    const elHudMenu = getElHudMenu();
    if (!elHudMenu) {
        return null;
    }
    return elHudMenu.querySelector(`[data-tooltip-id='hudMenuTooltip'][data-tooltip-content='${label}']`);
}

function getElHudMenuItemSelected() {
    const elHudMenu = getElHudMenu();
    if (!elHudMenu) {
        return null;
    }
    // Parse sub-menus (each sub-menu then contains the actual menu-items)
    for (const elHudMenuSubmenu of elHudMenu.children) {
        // Parse each menu-item in this sub-menu
        for (const elHudMenuItem of elHudMenuSubmenu.children) {
            if (elHudMenuItem.dataset.e115MenuId) {
                // Parsing an injected hud-menu item
                if (elHudMenuItem.dataset.e115State === 'selected') {
                    return elHudMenuItem;
                }
            } else {
                // Parsing a non-injected hud-menu item
                const reactProps = getReactPropsForEl(elHudMenuItem);
                if (reactProps && reactProps.selected) {
                    return elHudMenuItem;
                }
            }
        }
    }
    return null;
}

function getElCrewWindow() {
    const elCrewWindowBg = document.querySelector('div[src*="OwnedCrew"]');
    if (!elCrewWindowBg) {
        return null;
    }
    return elCrewWindowBg.parentElement;
}

/**
 * This function looks for the first VISIBLE previous-sibling, relative to the parent of the hud menu, because:
 * - when a ship is selected, the DOM contains an additional element BEFORE the left-side panels container
 * - when an asteroid is selected @ system-view, the DOM contains 2 hidden elements AFTER the left-side panels container
 */
function getElLeftSidePanelsContainer() {
    const elHudMenu = getElHudMenu();
    if (!elHudMenu) {
        return null;
    }
    let elPreviousSibling = elHudMenu.parentElement.previousElementSibling;
    if (!elPreviousSibling) {
        // This element does not exist on the initial page-load, before clicking "Play"
        return null;
    }
    if (!elPreviousSibling.offsetParent) {
        // Traverse up a limited number of previous siblings, until a visibile element is found
        for (let i = 1; i <= 5; i++) {
            elPreviousSibling = elPreviousSibling.previousElementSibling;
            if (elPreviousSibling.offsetParent) {
                break;
            }
        }
    }
    if (!elPreviousSibling.offsetParent) {
        // NO visible element found among previous siblings
        return null;
    }
    // At this point, "elPreviousSibling" should be the left-side panels container
    return elPreviousSibling;
}

function getElSelectedCrewPanel() {
    const elLeftSidePanelsContainer = getElLeftSidePanelsContainer();
    if (!elLeftSidePanelsContainer) {
        return null;
    }
    return elLeftSidePanelsContainer.firstElementChild;
}

/**
 * The selected location can be any of these:
 * - lot @ surface-view (empty lot / building / construction site / landed Light Transport)
 * - asteroid @ surface-view (if NO lot selected)
 * - asteroid @ system-view  (if zoomed-out)
 * - none @ system-view (if NO asteroid selected)
 * - ship (regardless if in shipyard / orbit / transit, but EXCLUDING landed Light Transport)
 */
function getElSelectedLocationPanel() {
    const elLeftSidePanelsContainer = getElLeftSidePanelsContainer();
    if (!elLeftSidePanelsContainer) {
        return null;
    }
    return elLeftSidePanelsContainer.lastElementChild;
}

function getSelectedCrewValues() {
    const elSelectedCrewPanel = getElSelectedCrewPanel();
    if (!elSelectedCrewPanel) {
        return null;
    }
    const reactFiberSelectedCrewPanel = getReactFiberForEl(elSelectedCrewPanel);
    if (!reactFiberSelectedCrewPanel || !reactFiberSelectedCrewPanel.memoizedProps) {
        return null;
    }
    const reactChildren = reactFiberSelectedCrewPanel.memoizedProps.children;
    const crewData = getReactPropDataFromChildrenRecursive('crew', reactChildren);
    return {
        crewValue: crewData.propValue,
    }
}

function getSelectedLocationValues() {
    const elSelectedLocationPanel = getElSelectedLocationPanel();
    if (!elSelectedLocationPanel) {
        return null;
    }
    const reactFiberSelectedLocationPanel = getReactFiberForEl(elSelectedLocationPanel);
    if (!reactFiberSelectedLocationPanel || !reactFiberSelectedLocationPanel.memoizedProps) {
        return null;
    }
    const reactChildren = reactFiberSelectedLocationPanel.memoizedProps.children;
    /**
     * Prop "lot" values, if found:
     * - object     = Warehouse / Extractor (incl. site) / Refinery / Factory / Bioreactor / Shipyard / Habitat / landed Light Transport @ surface-view / docked ship @ Spaceport
     * - null       = construction site for [Refinery / Factory / Bioreactor / Shipyard] / Spaceport (incl. site) / Marketplace @ surface-view
     * - undefined  = asteroid selected @ system-view
     */
    const lotData = getReactPropDataFromChildrenRecursive('lot', reactChildren);
    /**
     * Prop "ship" values, if found:
     * - object     = landed Light Transport @ surface-view / docked ship @ Spaceport
     * - null       = any other location selected (or NO asteroid selected @ system-view)
     */
    const shipData = getReactPropDataFromChildrenRecursive('ship', reactChildren);
    /**
     * Prop "asteroid" relevant only in system-view
     */
    const asteroidData = getReactPropDataFromChildrenRecursive('asteroid', reactChildren);
    /**
     * Prop "crewId" used when "lot" and "ship" are both null / undefined (e.g. Marketplace etc.)
     */
    const crewIdData = getReactPropDataFromChildrenRecursive('crewId', reactChildren);
    //// TO DO: test "lotData" + "shipData" for ship in orbit / in transit
    if (!lotData.foundOwnProperty && !shipData.foundOwnProperty && !asteroidData.foundOwnProperty && !crewIdData.foundOwnProperty) {
        return null;
    }
    return {
        asteroidValue: asteroidData.propValue,
        crewIdValue: crewIdData.propValue,
        lotValue: lotData.propValue,
        shipValue: shipData.propValue,
    }
}

/**
 * Return the ID for the currently selected location, formated as:
 * - "B1234" = selected building with ID 1234
 * - "S1234" = selected ship with ID 1234
 * - null = none of the above, OR selected building with NO data in React prop "lot" (see "getSelectedLocationValues")
 * 
 * NOTE: "locationValues" must be formatted as the return value of "getSelectedLocationValues"
 */
function getSelectedLocationId(locationValues) {
    if (!locationValues) {
        return null;
    }
    const {lotValue, shipValue} = {...locationValues};
    if (!lotValue && !shipValue) {
        return null;
    }
    if (shipValue) {
        // Landed Light Transport or docked ship @ Spaceport => location ID starts with "S"
        return `S${shipValue.id}`;
    }
    if (!lotValue.building) {
        /**
         * Prop "lot" found with "building" value "undefined" - e.g. landed Light Transport @ surface-view.
         * 
         * NOTE: If landed Light Transport, the following are defined:
         * - "lotValue.ships" (non-empty array)
         * - "lotValue.surfaceShip" (object - same as the first element of "lotValue.ships"?)
         */
        return null;
    }
    // Building with valid data => location ID starts with "B"
    return `B${lotValue.building.id}`;
}

function getCurrentAsteroidId() {
    let asteroidId = null;
    try {
        asteroidId = JSON.parse(localStorage.influence).state.asteroids.origin;
    } catch (error) {
        // Swallow this error, and continue with fallback
    }
    if (!asteroidId) {
        // Fallback from URL (only when the asteroid-details panel is open)
        const asteroidMatches = location.pathname.match(/\/asteroids\/(\d+)/);
        if (asteroidMatches) {
            asteroidId = Number(asteroidMatches[1]);
        }
    }
    return asteroidId;
}

function getCurrentCrewId() {
    let crewId = null;
    try {
        crewId = JSON.parse(localStorage.influence).state.selectedCrewId;
    } catch (error) {
        // Swallow this error, and continue with fallback
    }
    if (!crewId) {
        // Fallback from URL (only when the crew-details panel is open)
        const crewMatches = location.pathname.match(/\/crew\/(\d+)/);
        if (crewMatches) {
            crewId = Number(crewMatches[1]);
        }
    }
    return crewId;
}

function getCurrentWalletAddress() {
    let walletAddress = null;
    try {
        const sessions = JSON.parse(localStorage.influence).state.sessions;
        walletAddress = Object.keys(sessions)[0];
    } catch (error) {
        // Swallow this error, and continue with fallback
    }
    return walletAddress;
}

/**
 * e.g. "Thin-film Resistor" => "Thin-filmResistor"
 */
function getCompactName(name) {
    return name.replace(/\s+/g, '');
}

function getCompactAddress(address) {
    if (!address) {
        return null;
    }
    return address.replace(/^(.{6}).+(.{4})$/, '$1...$2');
}

function getToolUrlProductionPlanner() {
    // Hardcoding the URL from "tools" for {title: "Production Planner", author: "Elerium115"}
    return 'https://influence.elerium.dev/production-planner.html';
}

function getToolUrlProcessFinder() {
    // Hardcoding the URL from "tools" for {title: "Process Finder", author: "Denker"}
    return 'https://www.adalia.info/tools/process-finder';
}

/**
 * Source: Influence SDK - "src/lib/crew.js"
 * @param timeSinceFed In-game seconds since the crew was last fully fed
 */
const getCurrentFoodRatio = (timeSinceFed = 0, consumption = 1) => {
    const timeSinceFedInYears = timeSinceFed / YEAR_IN_SECONDS;
    const adjustedTimeSince = timeSinceFedInYears / consumption; // Simulates slower consumption
    return Math.min(
        Math.max(
            0,
            1 - adjustedTimeSince, // (not fasting)
            0.75 - 0.5 * adjustedTimeSince // (fasting)
        ),
        1
    );
};

/**
 * Get the DOM elements for each crew in the "My Crews" list,
 * if the "My Crews" panel is currently selected.
 */
function getElsMyCrews() {
    if (!isHudMenuPanelFor(hudMenuItemLabelMyCrews)) {
        return [];
    }
    const elsCrews = [];
    const elHudMenuPanel = getElHudMenuPanel();
    const elsCrewmateImages = elHudMenuPanel.querySelectorAll('img[src*="/crewmates/"]');
    elsCrewmateImages.forEach(elCrewmateImage => {
        const elCrew = elCrewmateImage.closest('[data-tooltip-id]').parentElement.parentElement.parentElement.parentElement;
        if (!elsCrews.includes(elCrew)) {
            elsCrews.push(elCrew);
        }
    });
    return elsCrews;
}

function getCloseButtonFromHudMenuPanel() {
    let elCloseButton = null;
    const elHudMenuPanel = getElHudMenuPanel();
    if (elHudMenuPanel) {
        // Find the wrapper for the header-buttons
        const elFirstButton = elHudMenuPanel.querySelector('button');
        if (elFirstButton) {
            const elHeaderButtonsWrapper = elFirstButton.parentElement;
            // The "close" button should be the last of the header-buttons
            elCloseButton = [...elHeaderButtonsWrapper.querySelectorAll('button')].pop();
        }
    }
    if (!elCloseButton) {
        // Fallback to ugly "close" button
        elCloseButton = createEl('div');
        elCloseButton.textContent = '✕';
    }
    return elCloseButton;
}

function isElHudMenuItemSelectedByLabel(label) {
    const elHudMenuItemSelected = getElHudMenuItemSelected();
    if (!elHudMenuItemSelected) {
        return false;
    }
    return elHudMenuItemSelected.dataset.tooltipContent === label;
}

/**
 * Return TRUE if the "targetSelectedState" has been reached, or FALSE otherwise / on timeout
 */
async function waitForHudMenuItemSelectedState(el, targetSelectedState, checkIntervalMs = 250, maxWaitMs = 2000) {
    const checkAttempts = maxWaitMs / checkIntervalMs;
    for (i = 0; i < checkAttempts ; i++) {
        /**
         * Always wait first, before checking the selected-state.
         * This ensures that any CSS transitions are visible, at least partially.
         */
        await delay(checkIntervalMs);
        const reactProps = getReactPropsForEl(el);
        if (!reactProps) {
            return false;
        }
        if (reactProps.selected === targetSelectedState) {
            return true;
        }
    }
    return false;
}

function createEl(nodeType, id = null, classes = null) {
    const el = document.createElement(nodeType);
    if (id) {
        el.id = id;
    }
    if (classes) {
        classes.forEach(className => el.classList.add(className));
    }
    return el;
}

function addTooltip(el, tooltipContent, tooltipPlace = 'top', tooltipId='globalTooltip') {
    el.dataset.tooltipId = tooltipId;
    el.dataset.tooltipPlace = tooltipPlace;
    el.dataset.tooltipContent = tooltipContent;
}

function removeTooltip(el) {
    delete el.dataset.tooltipId;
    delete el.dataset.tooltipPlace;
    delete el.dataset.tooltipContent;
}

function findElWithMatchingTextNode(elParent, descendantsSelector, text) {
    // Parse all descendants of "elParent" matching "descendantsSelector"
    const elsDescendants = elParent.querySelectorAll(descendantsSelector);
    for (const elDescendant of elsDescendants) {
        // Parse all nodes of "elDescendant"
        for (const elNode of [...elDescendant.childNodes]) {
            // Check if "elNode" is a text node with matching "text"
            if (elNode.nodeName === '#text' && elNode.textContent.trim().toLowerCase() === text.toLowerCase()) {
                return elDescendant;
            }
        }
    }
    return null;
}

function isHudMenuPanelFor(panelTitle) {
    const elHudMenuPanel = getElHudMenuPanel();
    if (!elHudMenuPanel) {
        return false;
    }
    return Boolean(findElWithMatchingTextNode(elHudMenuPanel.firstElementChild.firstElementChild, '*', panelTitle));
}

function isHudMenuPanelForInventory() {
    return isHudMenuPanelFor(hudMenuItemLabelLotInventory) || isHudMenuPanelFor(hudMenuItemLabelShipInventory);
}

function injectUrlParam(url, key, value) {
    const urlData = new URL(url);
    const urlParams = new URLSearchParams(urlData.search);
    urlParams.set(key, value);
    urlData.search = urlParams.toString();
    return urlData.href;
}

function onClickToolCategoryItem(title, url, autoInjectUrlParams) {
    // Check if window already exists with the same "title"
    const elMatchingWindow = document.querySelector(`[data-e115-window-id="${title}"]`);
    if (elMatchingWindow) {
        return;
    }
    // Close any injected window (but keep any official window)
    const elOldWindowClose = document.querySelector('.e115-window-close');
    if (elOldWindowClose) {
        elOldWindowClose.click();
    }
    // Prepare new standard window > wrapper
    const elNewWindowWrapper = createEl('div', null, ['e115-window-wrapper']);
    elNewWindowWrapper.dataset.e115WindowId = title; // data-e115-window-id
    // Prepare new standard window
    const elNewWindow = createEl('div', null, ['e115-window']);
    elNewWindowWrapper.append(elNewWindow);
    // Prepare new standard window > header
    const elNewWindowHeader = createEl('div', null, ['e115-window-header']);
    elNewWindow.append(elNewWindowHeader);
    // Prepare new standard window > header > title
    const elNewWindowHeaderTitle = createEl('h1', null, ['e115-window-title']);
    elNewWindowHeaderTitle.textContent = title;
    elNewWindowHeader.append(elNewWindowHeaderTitle);
    // Prepare new standard window > header > buttons-wrapper
    const elNewWindowHeaderButtons = createEl('div', null, ['e115-window-buttons']);
    elNewWindowHeader.append(elNewWindowHeaderButtons);
    // Prepare new standard window > header > buttons-wrapper > "Safety Tips"
    const elNewWindowHeaderWarning = createEl('div', null, ['e115-button', 'e115-cursor-full']);
    elNewWindowHeaderWarning.textContent = 'Safety Tips';
    elNewWindowHeaderWarning.addEventListener('mouseenter', () => toggleSafetyTips(true));
    elNewWindowHeaderWarning.addEventListener('mouseleave', () => toggleSafetyTips(false));
    elNewWindowHeaderButtons.append(elNewWindowHeaderWarning);
    // Prepare new standard window > header > buttons-wrapper > "Open in new window"
    const elNewWindowHeaderButton = createEl('a', null, ['e115-button', 'e115-cursor-full']);
    elNewWindowHeaderButton.href = url;
    elNewWindowHeaderButton.target = '_blank';
    elNewWindowHeaderButton.textContent = 'Open in new window';
    elNewWindowHeaderButtons.append(elNewWindowHeaderButton);
    // Prepare new standard window > header > buttons-wrapper > close
    const elNewWindowClose = closeButtonClone.cloneNode(true);
    elNewWindowClose.classList.add('e115-window-close'); // class used for closing the injected window
    // Define onclick handler to delete this window
    elNewWindowClose.dataset.onClickFunction = 'onClickNewWindowClose';
    elNewWindowClose.dataset.onClickArgs = JSON.stringify([title]);
    elNewWindowHeaderButtons.append(elNewWindowClose);
    // Prepare new standard window > content > Safety Tips
    const elNewWindowSafety = createEl('div', null, ['e115-window-content', 'e115-window-safety', 'e115-hidden']);
    elNewWindowSafety.innerHTML = /*html*/ `
        <h2>Safety Tips</h2>
        <ul>
            <li>This tool is embedded from a third-party website, without any guarantees, and beyond the control of <span class="e115-color-influence">${location.hostname}</span>.</li>
            <li>This embedded tool may trigger requests to your L1 and/or L2 wallet, but it does NOT have access to your game account.</li>
            <li>Ensure that you fully understand the origin and impact of any wallet request, before you approve it!</li>
        </ul>
    `;
    elNewWindow.append(elNewWindowSafety);
    // Prepare new standard window > content > iframe
    const elNewWindowIframe = createEl('iframe', null, ['e115-window-content']);
    let iframeUrl = url;

    if (autoInjectUrlParams) {
        // Inject ID of selected asteroid (if any) into the iframe URL
        const asteroidId = getCurrentAsteroidId();
        if (asteroidId) {
            iframeUrl = injectUrlParam(iframeUrl, 'influence_asteroid', asteroidId);
        }
    
        // Inject ID of selected crew (if any) into the iframe URL
        const crewId = getCurrentCrewId();
        if (crewId) {
            iframeUrl = injectUrlParam(iframeUrl, 'influence_crew', crewId);
        }
    
        // Inject the player's wallet address (if any) into the iframe URL
        const walletAddress = getCurrentWalletAddress();
        if (walletAddress) {
            // URL param name compatible with adalia.info tools, as of July 2024
            iframeUrl = injectUrlParam(iframeUrl, 'walletAddress', walletAddress);
        }
    }

    elNewWindowIframe.src = iframeUrl;
    elNewWindow.append(elNewWindowIframe);
    // Inject new standard window, as the first element in the "grand-parent" of the hud-menu
    const elHudMenu = getElHudMenu();
    const elWindowParent = elHudMenu.parentElement.parentElement;
    elWindowParent.prepend(elNewWindowWrapper);
}

function toggleSafetyTips(shouldBeVisible) {
    const elWindow = document.querySelector('.e115-window');
    if (!elWindow) {
        return;
    }
    if (shouldBeVisible) {
        elWindow.querySelector('iframe').classList.add('e115-hidden');
        elWindow.querySelector('.e115-window-safety').classList.remove('e115-hidden');
    } else {
        elWindow.querySelector('.e115-window-safety').classList.add('e115-hidden');
        elWindow.querySelector('iframe').classList.remove('e115-hidden');
    }
}

function onClickNewWindowClose(title) {
    // Delete the injected window
    const el = document.querySelector(`[data-e115-window-id='${title}']`);
    el.parentElement.removeChild(el);
}

function onClickToolCategoryTitle(category) {
    const elListItem = document.querySelector(`[data-e115-list-item-category="${category}"]`);
    if (!elListItem) {
        return;
    }
    const elListItemSelected = document.querySelector(`[data-e115-list-item-category].selected`);
    if (elListItemSelected && elListItemSelected !== elListItem) {
        // Another category currently selected => deselect it first
        elListItemSelected.classList.remove('selected');
    }
    elListItem.classList.toggle('selected');
}

function onClickInjectedHudMenuItem(label) {
    const elInjectedHudMenuItem = getElHudMenuItemByLabel(label);
    if (elInjectedHudMenuItem.dataset.e115State === 'selected') {
        // De-select the injected hud-menu item
        toggleInjectedMenuItemByLabel(label, false);
    } else {
        // Select the injected hud-menu item
        toggleInjectedMenuItemByLabel(label, true);
    }
}

function onClickInjectedHudMenuPanelCloseButton(label) {
    // De-select the injected hud-menu item
    toggleInjectedMenuItemByLabel(label, false);
}

async function toggleInjectedMenuItemByLabel(label, shouldBeSelected) {
    const elInjectedHudMenuItem = getElHudMenuItemByLabel(label);
    if (!elInjectedHudMenuItem) {
        //// TO DO: investigate how this may happen (observed once during local dev)
        return;
    }
    const elHudMenu = getElHudMenu();
    if (shouldBeSelected) {
        if (elInjectedHudMenuItem.dataset.e115State === 'selected') {
            // Abort if already selected
            return;
        }
        // De-select any non-injected hud-menu item, if currently selected
        const elHudMenuItemSelected = getElHudMenuItemSelected();
        if (elHudMenuItemSelected) {
            elHudMenuItemSelected.click();
            const targetSelectedStateReached = await waitForHudMenuItemSelectedState(elHudMenuItemSelected, false);
            if (!targetSelectedStateReached) {
                // hud-menu item did NOT become de-selected => ABORT
                console.log(`%c--- [toggleInjectedMenuItemByLabel] ABORT re: elHudMenuItemSelected did NOT become de-selected`, 'background: orange; color: black');
                return;
            }
        }
        elInjectedHudMenuItem.dataset.e115State = 'selected'; // data-e115-state
        elInjectedHudMenuItem.classList.value = hudMenuItemSelectedClassListValue;
        const elHudMenuPanel = getElHudMenuPanel();
        // The real hud-menu panel (closed, at this point) must be completely hidden
        elHudMenuPanel.style.display = 'none';
        // Inject the cloned hud-menu panel into the DOM
        elHudMenuPanel.parentElement.append(hudMenuPanelOpenClone);
        // Mark the hud-menu as open
        elHudMenu.classList.value = hudMenuOpenClassListValue;
    } else {
        if (elInjectedHudMenuItem.dataset.e115State !== 'selected') {
            // Abort if already de-selected
            return;
        }
        elInjectedHudMenuItem.dataset.e115State = ''; // data-e115-state
        elInjectedHudMenuItem.classList.value = hudMenuItemUnselectedClassListValue;
        const elHudMenuPanel = getElHudMenuPanel();
        // Remove the cloned hud-menu panel from the DOM
        elHudMenuPanel.parentElement.removeChild(hudMenuPanelOpenClone);
        // The real hud-menu panel must no longer be completely hidden
        elHudMenuPanel.style.removeProperty('display');
        // Mark the hud-menu as closed
        elHudMenu.classList.value = hudMenuClosedClassListValue;
        return;
    }
}

function injectConfig() {
    const elConfigPanel = createEl('div', 'e115-config-panel-wrapper');
    elConfigPanel.innerHTML = /*html*/ `
        <div id="e115-config-panel">
            <div id="e115-config-options"></div>
            <div id="e115-config-title" onclick="onClickConfigTitle()">Influence Tools extension</div>
        </div>
    `;
    document.body.append(elConfigPanel);
    // Inject config options
    injectConfigOptionCrewmateColorIntensity();
    injectConfigOptionCheckbox('auto-hide-markets-without-price', 'Auto-hide markets with no prices');
    injectConfigOptionCheckbox('auto-hide-used-deposits', 'Auto-hide used deposits');
    injectConfigOptionCheckbox('auto-open-inventory-panel', 'Auto-open inventories');
    injectConfigOptionCheckbox('auto-open-inventory-panel-bypass-other-panels', '... even if another menu item is open', true);
    injectConfigOptionCheckbox('auto-open-resources-panel', 'Auto-open resources for Extractors');
    injectConfigOptionCheckbox('auto-open-resources-panel-bypass-other-panels', '... even if another menu item is open', true);
    injectConfigOptionCheckbox('highlight-blocklisted-inventories', 'Highlight blocklisted inventories');
    injectConfigOptionCheckbox('highlight-crews-rationing', 'Highlight crews which are rationing');
    injectConfigOptionCheckbox('industry-builder-button', 'Process Finder button for warehouses');
    injectConfigOptionCheckbox('inventory-item-names', 'Overlay names for inventory items');
    injectConfigOptionCheckbox('location-controller', 'Controller(s) for the selected location');
    injectConfigOptionCheckbox('show-ship-stats-for-my-crews', 'Ship propellant percent for "My Crews"');
    // Initialize config options, based on extension settings from local-storage
    elConfigPanel.querySelector('input[name="auto-hide-markets-without-price"]').checked = extensionSettings.autoHideMarketsWithoutPrice;
    elConfigPanel.querySelector('input[name="auto-hide-used-deposits"]').checked = extensionSettings.autoHideUsedDeposits;
    elConfigPanel.querySelector('input[name="auto-open-inventory-panel"]').checked = extensionSettings.autoOpenInventoryPanel;
    elConfigPanel.querySelector('input[name="auto-open-inventory-panel-bypass-other-panels"]').checked = extensionSettings.autoOpenInventoryPanelBypassOtherPanels;
    elConfigPanel.querySelector('input[name="auto-open-resources-panel"]').checked = extensionSettings.autoOpenResourcesPanel;
    elConfigPanel.querySelector('input[name="auto-open-resources-panel-bypass-other-panels"]').checked = extensionSettings.autoOpenResourcesPanelBypassOtherPanels;
    elConfigPanel.querySelector('input[name="highlight-blocklisted-inventories"]').checked = extensionSettings.highlightBlocklistedInventories;
    elConfigPanel.querySelector('input[name="highlight-crews-rationing"]').checked = extensionSettings.highlightCrewsRationing;
    elConfigPanel.querySelector('input[name="industry-builder-button"]').checked = extensionSettings.industryBuilderButton;
    elConfigPanel.querySelector('input[name="inventory-item-names"]').checked = extensionSettings.inventoryItemNames;
    elConfigPanel.querySelector('input[name="location-controller"]').checked = extensionSettings.locationController;
    elConfigPanel.querySelector('input[name="show-ship-stats-for-my-crews"]').checked = extensionSettings.showShipStatsForMyCrews;
    // Initialize other data, based on extension settings from local-storage
    // -- set "data-auto-hide-markets-without-price" on "body"
    document.body.dataset.autoHideMarketsWithoutPrice = extensionSettings.autoHideMarketsWithoutPrice;
    // -- set "data-inventory-item-names" on "body"
    document.body.dataset.inventoryItemNames = extensionSettings.inventoryItemNames;
    // Set "data-only-my-inventories" on "body"
    document.body.dataset.onlyMyInventories = extensionSettings.onlyMyInventories;
    // Set "data-only-warehouses" on "body"
    document.body.dataset.onlyWarehouses = extensionSettings.onlyWarehouses;
}

function injectConfigOptionCrewmateColorIntensity() {
    const elConfigOptions = document.getElementById('e115-config-options');
    const elConfigOptionLabel = createEl('label');
    // Pre-select value from local-storage
    elConfigOptionLabel.innerHTML = /*html*/ `
        <input type="range" min="1" max="5" step="1" value="${extensionSettings.crewmateColorIntensity}" oninput="onInputCrewmateColorIntensity(this)"><span>Crewmate color</span>
    `;
    elConfigOptions.append(elConfigOptionLabel);
    // Apply the pre-selected value
    onInputCrewmateColorIntensity(elConfigOptionLabel.querySelector('input'));
}

function injectConfigOptionCheckbox(optionName, optionDescription, isSecondaryOption = false) {
    const elConfigOptions = document.getElementById('e115-config-options');
    const elConfigOptionLabel = createEl('label');
    elConfigOptionLabel.innerHTML = /*html*/ `
        <input type="checkbox" name="${optionName}" onclick="onClickConfigOption(this)"><span>${optionDescription}</span>
    `;
    if (isSecondaryOption) {
        elConfigOptionLabel.classList.add('e115-config-option-secondary')
    }
    elConfigOptions.append(elConfigOptionLabel);
}

function injectLoader() {
    const elLoader = createEl('div', 'e115-loader', ['e115-hidden']);
    document.body.append(elLoader);
}

function toggleLoader(shouldShow, message = '') {
    const elLoader = document.getElementById('e115-loader');
    if (!elLoader) {
        return;
    }
    elLoader.classList.toggle('e115-hidden', !shouldShow);
    elLoader.textContent = message;
}

async function updateCrewDataByCrewIdIfNotSet(crewId) {
    if (!crewId || crewDataByCrewId[crewId]) {
        return;
    }
    try {
        const crewDataResponse = await fetch(`${crewDataEndpoint}/${crewId}`);
        const crewData = await crewDataResponse.json();
        crewDataByCrewId[crewId] = crewData;
    } catch (error) {
        // Swallow this error
    }
}

async function updateCrewmateVideosIfNotSet() {
    if (crewmateVideos) {
        return;
    }
    try {
        const crewmateVideosResponse = await fetch(crewmateVideosEndpoint);
        crewmateVideos = await crewmateVideosResponse.json();
    } catch (error) {
        // Swallow this error
    }
}

/**
 * NOTE: These filters require inventories to be marked via "highlightBlocklistedInventories"
 */
function injectInventoriesFilters() {
    if (document.getElementById('e115-inventories-filters')) {
        // Filters already injected
        return;
    }
    const elAvailableInventoriesTitle = findElWithMatchingTextNode(document.body, '*', 'Available Inventories');
    if (!elAvailableInventoriesTitle) {
        return;
    }
    const elInventoriesFilters = createEl('div', 'e115-inventories-filters');
    // Inject filter for "Only My Inventories"
    injectFilterWithCheckbox(elInventoriesFilters, 'Only My Inventories', 'onlyMyInventories');
    // Inject filter for "Only Warehouses"
    injectFilterWithCheckbox(elInventoriesFilters, 'Only Warehouses', 'onlyWarehouses');
    // Inject the filter right after the title (before the close-button)
    const elAvailableInventoriesHeader = elAvailableInventoriesTitle.parentElement;
    elAvailableInventoriesHeader.insertBefore(elInventoriesFilters, elAvailableInventoriesTitle.nextSibling);
    // Auto-focus the native filter
    const elNativeFilter = elAvailableInventoriesHeader.parentElement.querySelector('input[placeholder="Filter by Name..."]');
    if (elNativeFilter) {
        elNativeFilter.focus();
    }
}

function injectFilterWithCheckbox(elFilterContainer, filterText, extensionSettingKey) {
    const elFilterWrapper = createEl('label', null, ['e115-filter', 'e115-cursor-full']);
    const elFilterInput = createEl('input');
    elFilterInput.type = 'checkbox';
    elFilterInput.checked = extensionSettings[extensionSettingKey];
    elFilterInput.addEventListener('input', () => {
        setExtensionSetting(extensionSettingKey, elFilterInput.checked);
        document.body.dataset[extensionSettingKey] = elFilterInput.checked;
        elFilterWrapper.classList.toggle('e115-checked', elFilterInput.checked);
    });
    elFilterWrapper.classList.toggle('e115-checked', elFilterInput.checked);
    elFilterWrapper.append(elFilterInput);
    const elFilterText = createEl('div');
    elFilterText.textContent = filterText;
    elFilterWrapper.append(elFilterText);
    elFilterContainer.append(elFilterWrapper);
}

async function updateInventoriesDataByLabelAndIdsIfNotSet(inventoriesLabel, inventoriesIds) {
    if (isUpdatingInventories) {
        // Wait for pending API calls for inventories data
        return;
    }
    isUpdatingInventories = true;
    let inventoriesLabelText = '';
    switch (inventoriesLabel) {
        case ENTITY_IDS.BUILDING:
            inventoriesLabelText = 'buildings';
            break;
        case ENTITY_IDS.SHIP:
            inventoriesLabelText = 'ships';
            break;
    }
    try {
        // Fetch data only for NON-cached IDs associated w/ this label
        const cachedData = inventoriesDataByLabelAndId[inventoriesLabel];
        const cachedIds = Object.keys(cachedData);
        const nonCachedIds = inventoriesIds.filter(id => !cachedIds.includes(id));
        if (nonCachedIds.length) {
            toggleLoader(true, `Updating data for ${nonCachedIds.length} ${inventoriesLabelText}...`);
            const nonCachedIdsList = nonCachedIds.join(',');
            const inventoriesDataResponse = await fetch(`${inventoriesDataEndpoint}/${inventoriesLabel}/${nonCachedIdsList}`);
            const inventoriesData = await inventoriesDataResponse.json();
            nonCachedIds.forEach(inventoryId => {
                inventoriesDataByLabelAndId[inventoriesLabel][inventoryId] = inventoriesData[inventoryId];
            });
        }
    } catch (error) {
        // Swallow this error
    }
    isUpdatingInventories = false;
    toggleLoader(false);
}

async function updatePrices() {
    try {
        const pricesResponse = await fetch(pricesEndpoint);
        prices = await pricesResponse.json();
    } catch (error) {
        // Swallow this error
    }
}

async function updateShipDataByShipIdIfNotSet(shipId) {
    if (!shipId || shipDataByShipId[shipId]) {
        return;
    }
    try {
        const shipDataResponse = await fetch(`${shipDataEndpoint}/${shipId}`);
        const shipData = await shipDataResponse.json();
        shipDataByShipId[shipId] = shipData;
    } catch (error) {
        // Swallow this error
    }
}

async function updateToolsIfNotSet() {
    if (tools) {
        return;
    }
    try {
        const toolsResponse = await fetch(toolsEndpoint);
        tools = await toolsResponse.json();
    } catch (error) {
        // Swallow this error
    }
}

async function updateWidgetsIfNotSet() {
    if (widgets) {
        return;
    }
    try {
        const widgetsResponse = await fetch(widgetsEndpoint);
        widgets = await widgetsResponse.json();
    } catch (error) {
        // Swallow this error
    }
}

/**
 * Get the VISIBLE top-menu, depending on the state of the main-menu:
 * - main-menu open => 2 elements matching "selectorTopMenu" (only 1 visible)
 * - main-menu closed => 1 element matching "selectorTopMenu" (visible)
 */
function getVisibleTopMenu() {
    const elsTopMenu = document.querySelectorAll(selectorTopMenu);
    for (const elTopMenu of elsTopMenu) {
        if (elTopMenu.offsetParent) {
            // Visible top-menu
            return elTopMenu;
        }
    }
    // No visible top-menu
    return null;
}

function getElGameTimeWrapper() {
    const elTimeMenu = document.querySelector(selectorTimeMenu);
    if (!elTimeMenu) {
        // Not yet visible, or element removed from DOM on low-res
        return null;
    }
    let elGameTimeWrapper = elTimeMenu.lastElementChild;
    if (elGameTimeWrapper.id === 'e115-real-time') {
        // Real-time already injected => game-time is the previous element
        elGameTimeWrapper = elGameTimeWrapper.previousElementSibling;
    }
    return elGameTimeWrapper;
}

function getGameTimeDays() {
    const elGameTimeWrapper = getElGameTimeWrapper();
    if (!elGameTimeWrapper) {
        // Not yet visible, or element removed from DOM on low-res
        return 0;
    }
    return elGameTimeWrapper.lastElementChild.textContent.replace(/,/g, '');
}

function injectRealTime() {
    // Inject the real-time only after the time-menu is loaded and visible
    const existCondition = setInterval(async () => {
        // Wait for the time-menu to become visible
        const elTimeMenu = document.querySelector(selectorTimeMenu);
        if (!elTimeMenu || !elTimeMenu.offsetParent) {
            // Not yet visible
            return;
        }
        // Stop waiting
        clearInterval(existCondition);
        const elRealTime = createEl('div', 'e115-real-time');
        elTimeMenu.append(elRealTime);
        let gameTimeDaysCurrent = getGameTimeDays();
        // Periodically update the real-time, based on the game-time
        setInterval(() => {
            const elGameTimeWrapper = getElGameTimeWrapper();
            if (!elGameTimeWrapper) {
                return;
            }
            const elGameTimeControls = elGameTimeWrapper.firstElementChild;
            if (elGameTimeControls.hasAttribute('open')) {
                // Game-time controls open => show real-time
                elRealTime.classList.remove('e115-hidden');
                // Update the real-time, based on the user-previewed game-time
                const gameTimeDaysPreviewed = getGameTimeDays();
                const realTimeDaysDiff = (gameTimeDaysPreviewed - gameTimeDaysCurrent) / 24;
                const nowTs = new Date().getTime();
                const realTimeDiffTs = realTimeDaysDiff * 24 * 60 * 60 * 1000;
                const realTimePreviewedDate = new Date(nowTs + realTimeDiffTs);
                // Format real-time based on the user's locale and timezone
                elRealTime.textContent = Intl.DateTimeFormat(undefined, {
                    dateStyle: 'long',
                    timeStyle: 'long',
                }).format(realTimePreviewedDate);
            } else {
                // Game-time controls closed => hide real-time
                elRealTime.classList.add('e115-hidden');
                // Save the current game-time
                gameTimeDaysCurrent = getGameTimeDays();
            }
        }, 100);
    }, 1000);
}

function updateCrewData() {
    const selectedCrewValues = getSelectedCrewValues();
    try {
        selectedCrewData.rationing = selectedCrewValues.crewValue._foodBonuses.rationing;
    } catch (error) {
        selectedCrewData.rationing = null;
    }
    // Mark the selected crew panel for CSS
    const elSelectedCrewPanel = getElSelectedCrewPanel();
    if (elSelectedCrewPanel) {
        elSelectedCrewPanel.classList.add('e115-selected-crew-panel');
    }
}

function updateLocationData() {
    selectedLocationData.idPrevious = selectedLocationData.idCurrent;
    const selectedLocationValues = getSelectedLocationValues();
    const selectedLocationId = getSelectedLocationId(selectedLocationValues);
    selectedLocationData.idCurrent = selectedLocationId;
    try {
        selectedLocationData.buildingType = selectedLocationValues.lotValue.building.Building.buildingType;
    } catch (error) {
        selectedLocationData.buildingType = null;
    }
    // System-view if "lotValue" undefined (NOT if "null")
    selectedLocationData.isSystemView = selectedLocationValues && typeof selectedLocationValues.lotValue === 'undefined';
    let buildingCrewId = null;
    let shipCrewId = null;
    let asteroidCrewId = null;
    let lotCrewId = null;
    // Try each of these separately, in case any of them is undefined
    // -- building
    try {
        buildingCrewId = selectedLocationValues.lotValue.building.Control.controller.id;
    } catch (error) {
        // Swallow this error (i.e. leave "buildingCrewId" as "null")
    }
    // -- ship
    try {
        shipCrewId = selectedLocationValues.shipValue.Control.controller.id;
    } catch (error) {
        // Swallow this error (i.e. leave "shipCrewId" as "null")
    }
    // -- asteroid @ system-view
    try {
        asteroidCrewId = selectedLocationValues.asteroidValue.Control.controller.id;
    } catch (error) {
        // Swallow this error (i.e. leave "asteroidCrewId" as "null")
    }
    // -- lot
    try {
        lotCrewId = selectedLocationValues.lotValue.Control.controller.id;
    } catch (error) {
        // Swallow this error (i.e. leave "lotCrewId" as "null")
    }
    if (!lotCrewId) {
        // Fallback to "crewIdValue" when "lot" is null / undefined (e.g. Marketplace etc.)
        try {
            lotCrewId = selectedLocationValues.crewIdValue;
        } catch (error) {
            // Swallow this error (i.e. leave "lotCrewId" as "null")
        }
    }
    selectedLocationData.controllerData = {
        asteroidCrewId,
        buildingCrewId,
        lotCrewId,
        shipCrewId,
    };
    // Update crew data via API, for each UNIQUE crew ID
    const crewIds = Object.values(selectedLocationData.controllerData);
    const crewIdsUnique = [...new Set(crewIds)];
    crewIdsUnique.forEach(crewId => {
        updateCrewDataByCrewIdIfNotSet(crewId);
    });
}

async function searchMarketplace(searchText) {
    const elHudMenuMarketplace = getElHudMenuItemByLabel(hudMenuItemLabelMarketplace);
    if (!elHudMenuMarketplace) {
        return;
    }
    elHudMenuMarketplace.click();
    // Wait for the Marketplace window to load
    await delay(1000);
    const elInput = document.querySelector('input[placeholder="Search by Name"]');
    if (!elInput) {
        console.log(`%c--- [searchMarketplace] ERROR: elInput not found`, 'background: red');
        return;
    }
    // Source: https://stackoverflow.com/a/76212435
    Object.defineProperty(elInput, "value", {
        value: searchText,
        writable: true,
    });
    var inputEvent = new Event('input', {bubbles: true});
    elInput.dispatchEvent(inputEvent);
    // Wait for search results to load
    await delay(500);
    const elResultsListWrapper = elInput.parentElement.nextElementSibling;
    if (!elResultsListWrapper) {
        // Isolated occurrence, not sure how to reproduce
        return;
    }
    const elResultsList = elResultsListWrapper.firstElementChild;
    const elsResults = [...elResultsList.children];
    if (elsResults.length === 1) {
        // Auto-click if single result matching the search
        elsResults[0].click();
    }
}

function getMarketValueOfSelectedItems(elItemsList) {
    let marketValue = 0;
    [...elItemsList.children].forEach(elParsedItemWrapper => {
        const reactProps = getReactPropsForEl(elParsedItemWrapper);
        if (!reactProps || !reactProps.selected) {
            return;
        }
        const selectedQty = reactProps.selected;
        const productName = elParsedItemWrapper.querySelector('[data-tooltip-content]').dataset.tooltipContent;
        if (!productName || !prices[productName]) {
            return;
        }
        const productPrice = prices[productName] * selectedQty;
        marketValue += productPrice;
    });
    return marketValue;
}

/**
 * Update the market value of the selected inventory items, using their current quantities.
 * The quantity may be changed by the player, without triggering "onClickInventoryItem".
 * But this function requires "elSelectedProductsInfo" to already be marked
 * with "data-e115-market-value", during "onClickInventoryItem".
 */
function updateMarketValueOfSelectedItems() {
    const elSelectedProductsInfo = document.querySelector('[data-e115-market-value');
    if (!elSelectedProductsInfo) {
        return;
    }
    const elItemsList = elSelectedProductsInfo.parentElement.previousElementSibling;
    if (!elItemsList) {
        return;
    }
    const marketValue = getMarketValueOfSelectedItems(elItemsList);
    const marketValueFormatted = Intl.NumberFormat().format(parseInt(marketValue));
    elSelectedProductsInfo.dataset.e115MarketValue = `Market value: ${marketValueFormatted} SWAY`;
}

/**
 * Inject relevant buttons in the inventory-footer, if a single inventory item is selected.
 * Also inject market value of selected items in the inventory-footer.
 * 
 * NOTE re: injecting the "Search in Marketplace" button
 * - This only works for inventories where the "Marketplace" button exists in the hud-menu (Warehouse / contruction site).
 * - It does NOT work for ship-cargo and ship-propellant inventories.
 */
function onClickInventoryItem(elItem) {
    if (!isHudMenuPanelForInventory()) {
        /**
         * The current hud menu panel is not for an inventory menu item.
         * Do not continue, because this function is also triggered for items
         * in other panels (e.g. "Lot Info", "Asteroid Chat").
         */
        return;
    }
    const elItemWrapper = elItem.parentElement;
    const elItemsList = elItemWrapper.parentElement;
    const elInventoryFooter = elItemsList.nextElementSibling;
    if (!elInventoryFooter) {
        return;
    }
    let countSelected = 0;
    let elItemSelected = null;
    [...elItemsList.children].forEach(elParsedItemWrapper => {
        const reactProps = getReactPropsForEl(elParsedItemWrapper);
        if (reactProps && reactProps.selected) {
            elItemSelected = elParsedItemWrapper;
            countSelected++;
        }
    });
    /**
     * ALWAYS remove any injected buttons, to avoid duplicating them in this scenario:
     * - open inventory #1, select product #A => 1st set of inventory-buttons injected
     * - open inventory #2, select product #B => 2nd set of inventory-buttons injected
     */
    elInventoryFooter.querySelectorAll('.e115-button-inventory').forEach(elButton => {
        elButton.parentElement.removeChild(elButton);
    });
    if (countSelected === 1) {
        // Single item selected => inject relevant buttons
        const elItemSelectedName = elItemSelected.querySelector('[data-tooltip-content]').dataset.tooltipContent;
        // -- Inject "Search in Marketplace" button
        // ---- This only works for inventories where the "Marketplace" button exists in the hud-menu (Warehouse / contruction site).
        // ---- It does NOT work for ship-cargo and ship-propellant inventories.
        const elHudMenuMarketplace = getElHudMenuItemByLabel(hudMenuItemLabelMarketplace);
        if (elHudMenuMarketplace) {
            const elMarketplaceButton = createEl('div', null, ['e115-button', 'e115-button-inventory']);
            addTooltip(elMarketplaceButton, 'Search in Marketplace');
            elMarketplaceButton.innerHTML = svgIconSearch;
            elMarketplaceButton.dataset.onClickFunction = 'searchMarketplace';
            elMarketplaceButton.dataset.onClickArgs = JSON.stringify([elItemSelectedName]);
            elInventoryFooter.append(elMarketplaceButton);
        }
        // -- Inject "Production Planner" button
        const elProductionButton = createEl('div', null, ['e115-button', 'e115-button-inventory']);
        addTooltip(elProductionButton, 'Production Planner');
        elProductionButton.innerHTML = svgIconProductionChains;
        // ---- On click, open the item's production chain using the "Production Planner" tool
        const itemNameCompact = getCompactName(elItemSelectedName);
        const productionPlannerUrl = getToolUrlProductionPlanner() + '#' + itemNameCompact;
        if (!closeButtonClone) {
            closeButtonClone = getCloseButtonFromHudMenuPanel().cloneNode(true);
        }
        elProductionButton.dataset.onClickFunction = 'onClickToolCategoryItem';
        elProductionButton.dataset.onClickArgs = JSON.stringify(['Production Planner', productionPlannerUrl, true]);
        elInventoryFooter.append(elProductionButton);
    }
    // Inject market value of selected items
    const elSelectedProductsInfo = elInventoryFooter.querySelector('div[content*="Product"]');
    if (elSelectedProductsInfo) {
        const marketValue = getMarketValueOfSelectedItems(elItemsList);
        const marketValueFormatted = Intl.NumberFormat().format(parseInt(marketValue));
        elSelectedProductsInfo.dataset.e115MarketValue = `Market value: ${marketValueFormatted} SWAY`;
    }
}

function onMouseoverCaptainVideoPlay() {
    const elCaptainVideoWrapper = document.getElementById('e115-captain-video-wrapper');
    if (!elCaptainVideoWrapper) {
        return;
    }
    elCaptainVideoWrapper.classList.remove('e115-video-icon-only');
    // Load the video from the start
    elCaptainVideo = document.getElementById('e115-captain-video');
    if (!elCaptainVideo) {
        return;
    }
    elCaptainVideo.load();
}

function onCaptainVideoEnded() {
    const elCaptainVideoWrapper = document.getElementById('e115-captain-video-wrapper');
    if (!elCaptainVideoWrapper) {
        return;
    }
    elCaptainVideoWrapper.classList.add('e115-video-icon-only');
}

/**
 * Inject the captain-video if available for the currently opened crew, if any
 */
async function injectCaptainVideo() {
    if (!location.pathname.match(/^\/crew\/(\d+)/)) {
        // Crew window NOT open
        return;
    }
    if (document.getElementById('e115-captain-video')) {
        // Captain video already injected
        return;
    }
    const elCrewWindow = getElCrewWindow();
    if (!elCrewWindow) {
        return;
    }
    const elCaptainImg = elCrewWindow.querySelector('img[src*="/crewmates/"]');
    if (!elCaptainImg) {
        return;
    }
    const elCaptainCrewmateIdMatches = elCaptainImg.src.match(/\/crewmates\/(\d+)/);
    if (!elCaptainCrewmateIdMatches) {
        return;
    }
    const elCaptainCrewmateId = elCaptainCrewmateIdMatches[1];
    // If crewmate-videos not yet fetched (async), they need to be fetched now (sync), before continuing
    if (!crewmateVideos) {
        await updateCrewmateVideosIfNotSet();
    }
    if (crewmateVideos && crewmateVideos[elCaptainCrewmateId]) {
        const elCaptainVideoWrapper = createEl('div', 'e115-captain-video-wrapper');
        const elCaptainVideo = createEl('video', 'e115-captain-video');
        elCaptainVideo.controls = true;
        elCaptainVideo.src = crewmateVideos[elCaptainCrewmateId];
        elCaptainVideo.addEventListener('ended', onCaptainVideoEnded);
        elCaptainVideoWrapper.append(elCaptainVideo);
        // Inject overlay with "play" icon over the captain-video (hidden if the video is visible)
        const elCaptainVideoPlayIcon = createEl('div', 'e115-video-play-icon');
        elCaptainVideoPlayIcon.addEventListener('mouseenter', onMouseoverCaptainVideoPlay);
        elCaptainVideoWrapper.append(elCaptainVideoPlayIcon);
        elCaptainImg.parentElement.prepend(elCaptainVideoWrapper);
    }
}

function injectCrewController() {
    const crewIdMatches = location.pathname.match(/^\/crew\/(\d+)/);
    if (!crewIdMatches) {
        // Crew window NOT open
        return;
    }
    const elCrewWindow = getElCrewWindow();
    if (!elCrewWindow) {
        return;
    }
    const elCrewId = elCrewWindow.querySelector('[label="Crew ID"]');
    if (!elCrewId) {
        return;
    }
    let elCrewController = document.getElementById('e115-crew-controller');
    if (!elCrewController) {
        // Crew controller not yet injected
        elCrewController = createEl('div', 'e115-crew-controller');
        elCrewController.className = elCrewId.className; // mimic styling of crew ID label
        elCrewController.classList.add('e115-cursor-full');
        // Inject the crew controller label, right after the crew ID label
        elCrewId.parentElement.insertBefore(elCrewController, elCrewId.nextSibling);
    }
    // Update the crew controller label
    const crewId = crewIdMatches[1];
    updateCrewDataByCrewIdIfNotSet(crewId);
    try {
        const delegatedToAddress = crewDataByCrewId[crewId].delegatedToAddress;
        const delegatedToName = crewDataByCrewId[crewId].delegatedToName;
        let crewControllerText = delegatedToName;
        let crewControllerTextIsCustom = false;
        let crewControllerTextIsAddress = false;
        const crewControllerTextIsBlacklisted = customBlacklistByAddress[delegatedToAddress];
        // Prioritize custom label
        const crewControllerAddress = delegatedToAddress;
        if (customNameByAddress[crewControllerAddress]) {
            crewControllerText = customNameByAddress[crewControllerAddress];
            crewControllerTextIsCustom = true;
        }
        // Fallback to address
        if (!crewControllerText) {
            crewControllerText = delegatedToAddress;
            crewControllerTextIsAddress = true;
        }
        setupElControllerItem('crew', crewControllerText, crewControllerTextIsCustom, crewControllerTextIsAddress, crewControllerTextIsBlacklisted, elCrewController);
    } catch (error) {
        // Swallow this error
    }
}

/**
 * Inject a filter into the "Select Process" window, if any.
 * 
 * NOTE: Even though native filters for processes are now available,
 * this injected filter remains more useful for some searches.
 */
function injectProcessFilter() {
    if (document.getElementById('e115-filter-select-process')) {
        // Filter already injected
        return;
    }
    const elSelectProcessWindow = [...document.body.children].find(el => el.textContent.toLowerCase().includes('select process'));
    if (!elSelectProcessWindow) {
        // Select Process window NOT open
        return;
    }
    elSelectProcessWindow.classList.add('e115-select-process-window');
    const elSelectProcessTitle = [...elSelectProcessWindow.getElementsByTagName('div')].find(el => el.firstChild && el.firstChild.nodeName === '#text' && el.firstChild.textContent.trim().toLowerCase() === 'select process');
    if (!elSelectProcessTitle) {
        // Maybe the game's DOM structure has changed?
        return;
    }
    const elSelectProcessHeader = elSelectProcessTitle.parentElement;
    const elFilterWrapper = createEl('div', 'e115-filter-select-process');
    const elFilterInput = createEl('input', null, ['e115-input']);
    elFilterInput.type = 'text';
    elFilterInput.placeholder = 'Filter by process, input or output';
    elFilterInput.addEventListener('keyup', event => {
        /**
         * Prevent event-bubbling when the user presses any key other than "Escape", while typing into the filter-input.
         * - This allows the native logic to close the "Select Process" window when the user presses "Escape".
         * - But it prevents the window from closing when the user presses "Space" - e.g. typing "iron oxide".
         */
        if (event.key !== 'Escape') {
            event.stopPropagation();
        }
    });
    elFilterInput.addEventListener('input', () => {
        filterProcessesList(elFilterInput.value);
    });
    elFilterWrapper.append(elFilterInput);
    // Inject the filter right after the title (before the close-button)
    elSelectProcessHeader.insertBefore(elFilterWrapper, elSelectProcessTitle.nextSibling);
    elFilterInput.focus();
}

function filterProcessesList(elFilterInputValue) {
    const elSelectProcessWindow = document.querySelector('.e115-select-process-window');
    if (!elSelectProcessWindow) {
        // This function should NOT be called without the "Select Process" window having been marked, during the filter-injection
        return;
    }
    const filterText = elFilterInputValue.toLowerCase().trim();
    [...elSelectProcessWindow.querySelectorAll("tbody tr")].forEach(elRow => {
        if (!filterText) {
            // Show all processes if no text in filter-input
            elRow.classList.remove('e115-hidden');
            return;
        }
        let isMatch = false;
        if (elRow.textContent.toLowerCase().includes(filterText)) {
            // Process name matches the filter
            isMatch = true;
        } else {
            [...elRow.querySelectorAll('[data-tooltip-content]')].some(elProduct => {
                if (elProduct.dataset.tooltipContent.toLowerCase().includes(filterText)) {
                    // An input or output name matches the filter
                    isMatch = true;
                    return true; // skip remaining inputs / outputs
                }
            });
        }
        elRow.classList.toggle('e115-hidden', !isMatch);
    });
}

/**
 * Inject links on products from "My Open Limit Orders", if that window is open
 */
function injectMyOrdersProductLinks() {
    if (!location.pathname.match(/^\/marketplace\/(\d+)\/all\/orders/)) {
        // My Open Limit Orders window NOT open
        return;
    }
    const elMarketplaceHeader = document.querySelector('div[src*="/static/media/Marketplace"]');
    if (!elMarketplaceHeader || !elMarketplaceHeader.offsetParent) {
        // Not yet visible (e.g. on full page reload with this URL, before clicking "Play")
        return;
    }
    const elOrdersTable = elMarketplaceHeader.parentElement.querySelector('table');
    if (!elOrdersTable) {
        return;
    }
    // Fix re: final columns not visible on low-res (e.g. cancel-order buttons)
    elOrdersTable.parentElement.style.overflow = 'auto';
    const elsOrderRows = elOrdersTable.querySelectorAll('tbody tr');
    [...elsOrderRows].some(elOrderRow => {
        if (elOrderRow.classList.contains('e115-marked')) {
            // Order already parsed
            return;
        }
        const elProductCell = elOrderRow.querySelector('td:nth-child(3)');
        if (!elProductCell) {
            // Maybe the game's DOM structure has changed?
            return true; // skip remaining orders
        }
        elProductCell.classList.add('e115-color-influence', 'e115-cursor-full');
        elProductCell.addEventListener('click', () => {
            searchMarketplace(elProductCell.textContent.trim());
        });
        elOrderRow.classList.add('e115-marked');
    });
}

/**
 * Inject extraction-percent input if the "Extract Resource" window is open and ready to start extraction
 */
async function injectAndApplyExtractionPercent() {
    if (document.getElementById('e115-extraction-percent-wrapper')) {
        // Extraction-percent input already injected
        return;
    }
    const elExtractionHeader = document.querySelector('div[src*="/static/media/Extraction"]');
    if (!elExtractionHeader) {
        // Extract Resource window NOT open
        return;
    }
    // Find the "MAX" button, if any
    const elMaxButton = [...elExtractionHeader.parentElement.querySelectorAll('button')].find(elButton => elButton.textContent.toLowerCase().includes('max'));
    if (!elMaxButton) {
        // NOT ready to start extraction
        return;
    }
    const elExtractionDuration = elMaxButton.previousElementSibling;
    if (elExtractionDuration.textContent.trim() === '0s' && elMaxButton.disabled) {
        /**
         * NO deposit selected, i.e. extraction duration "0s" AND "elMaxButton" disabled.
         * 
         * NOTE: If the deposit is selected AFTER this window is open,
         * the extraction duration will remain "0s", but "elMaxButton" will become enabled.
         */
        return;
    }
    // Inject the extraction-percent input, before "elExtractionDuration"
    const elPercentWrapper = createEl('div', 'e115-extraction-percent-wrapper');
    const elPercentInput = createEl('input', null, ['e115-input']);
    elPercentInput.type = 'text';
    elPercentInput.addEventListener('input', () => {
        applyExtractionPercent(elPercentWrapper, elPercentInput.value);
    });
    elPercentWrapper.append(elPercentInput);
    elMaxButton.parentElement.insertBefore(elPercentWrapper, elExtractionDuration);
    // Force-click the "MAX" button, in case the deposit was selected after this window was open
    elMaxButton.click();
    // Wait for the animated increase of the extraction amount
    await delay(500);
    /**
     * Save the MAX extraction amount (i.e. 100% of deposit amount).
     * The value must be retrieved from the input (triggered via "mouseenter"),
     * to avoid issues with parsing "textContent" in different locales => different number formats.
     */
    const elAmountTextWrapper = elMaxButton.parentElement.children[0];
    await triggerExtractionAmountInput(elAmountTextWrapper);
    const elAmountInput = elAmountTextWrapper.querySelector('input');
    if (!elAmountInput) {
        // Maybe the game's DOM structure has changed?
        return;
    }
    extractionAmountMax = elAmountInput.value;
    // Apply the preferred extraction-percent from local-storage, if any
    applyExtractionPercent(elPercentWrapper);
}

/**
 * Apply the extraction-percent, and save it into local-storage.
 * If no "percentValue" given, apply the preferred extraction-percent from local-storage, if any.
 */
async function applyExtractionPercent(elPercentWrapper, percentValue = null) {
    if (!percentValue) {
        // NO value passed into this function => use the value from local-storage
        percentValue = extensionSettings.extractionPercent;
    }
    // Ensure "percentValue" is integer, MAX 100
    percentValue = Math.min(parseInt(`0${percentValue}`), 100);
    /**
     * Set "percentValue" into the input, in case it was either:
     * - not passed into this function, but retrieved from local-storage
     * - passed into this function as non-integer, and then forced to integer
     */
    elPercentWrapper.querySelector('input').value = percentValue;
    // Save the value into local-storage
    setExtensionSetting('extractionPercent', percentValue);
    // Apply the extraction-percent, via hover over "elAmountWrapper"
    const elAmountTextWrapper = elPercentWrapper.previousElementSibling;
    await triggerExtractionAmountInput(elAmountTextWrapper);
    const elAmountInput = elAmountTextWrapper.querySelector('input');
    if (!elAmountInput) {
        // Maybe the game's DOM structure has changed?
        return;
    }
    // Round down, to avoid a new value larger than MAX for 100%
    let newAmount = Math.floor(extractionAmountMax * percentValue / 100);
    /**
     * Set the new amount via workaround for React
     * Source: https://stackoverflow.com/a/66663506
     */
    const valueSetter = Object.getOwnPropertyDescriptor(elAmountInput, 'value').set;
    const prototype = Object.getPrototypeOf(elAmountInput);
    const prototypeValueSetter = Object.getOwnPropertyDescriptor(prototype, 'value').set;
    if (valueSetter && valueSetter !== prototypeValueSetter) {
        prototypeValueSetter.call(elAmountInput, newAmount);
    } else {
        valueSetter.call(elAmountInput, newAmount);
    }
    elAmountInput.dispatchEvent(new Event('input', {bubbles: true}));
}

async function triggerExtractionAmountInput(elAmountTextWrapper) {
    if (elAmountTextWrapper.querySelector('input')) {
        // Input already triggered
        return;
    }
    if (!elAmountTextWrapper) {
        // Maybe the game's DOM structure has changed?
        return;
    }
    const reactPropsWrapper = getReactPropsForEl(elAmountTextWrapper);
    if (!reactPropsWrapper || typeof reactPropsWrapper.onMouseEnter !== 'function') {
        // Maybe something else has changed?
        return;
    }
    reactPropsWrapper.onMouseEnter(new Event('mouseenter'));
    // Wait for the amount input to appear
    await delay(100);
}

function injectIndustryBuilderButton() {
    if (!extensionSettings.industryBuilderButton) {
        return;
    }
    if (!isHudMenuPanelForInventory()) {
        /**
         * The current hud menu panel is not for an inventory menu item.
         * Do not continue, otherwise "elInventoryItem" would also match
         * in other panels (e.g. "Lot Info", "Asteroid Chat").
         */
        return;
    }
    const elInventoryItem = document.querySelector(`${selectorHudMenuPanel} [data-tooltip-id='hudMenuTooltip'][data-tooltip-content]`);
    let elIndustryButton = document.getElementById('e115-industry-builder-button');
    if (!elInventoryItem || !selectedLocationData.idCurrent.startsWith('B')) {
        // Inventory not open, or no items in inventory, or not a Warehouse (i.e. a ship)
        if (elIndustryButton) {
            // Remove button injected for a previous inventory
            elIndustryButton.parentElement.removeChild(elIndustryButton);
        }
        return;
    }
    if (!elIndustryButton) {
        // Inject the button ABOVE the items-list container
        elIndustryButton = createEl('div', 'e115-industry-builder-button', ['e115-button', 'e115-button-inventory']);
        addTooltip(elIndustryButton, 'What can I make with these items?');
        elIndustryButton.innerHTML = svgIconFactoryArrows;
        const elInventoryItemWrapper = elInventoryItem.parentElement;
        elInventoryItemWrapper.parentElement.previousElementSibling.append(elIndustryButton);
    }
    /**
     * Set the tool-URL of "elIndustryButton" based on "selectedLocationData.idCurrent".
     * At this point, the button may be either newly injected with no tool-URL,
     * or previously injected with an obsolete tool-URL.
     * 
     * NOTE: Set "autoInjectUrlParams" to FALSE for "onClickToolCategoryItem", to avoid injecting
     * the URL param "walletAddress". This ensures that the "Process Finder" tool only receives
     * the URL param "warehouses", allowing it to also be used for Warehouses owned by other players.
     */
    const warehouseId = selectedLocationData.idCurrent.replace('B', '');
    const processFinderUrl = getToolUrlProcessFinder() + '?warehouses=' + warehouseId;
    elIndustryButton.dataset.onClickFunction = 'onClickToolCategoryItem';
    elIndustryButton.dataset.onClickArgs = JSON.stringify(['Process Finder', processFinderUrl, false]);
}

function injectLocationController() {
    if (!extensionSettings.locationController) {
        /**
         * Ensure the location controller is hidden, if the player
         * disables this feature from the extension-settings.
         */
        resetElLocationController();
        return;
    }
    if (!elLocationController) {
        elLocationControllerWrapper = createEl('div', 'e115-location-controller-wrapper', ['e115-hidden']);
        elLocationController = createEl('div', 'e115-location-controller', ['e115-cursor-full']);
        elLocationController.innerHTML = /*html*/ `
            <div class="controller controller-building"></div>
            <div class="controller controller-ship"></div>
            <div class="controller controller-lot"></div>
            <div class="controller controller-asteroid"></div>
        `;
        elLocationControllerWrapper.append(elLocationController);
        document.body.append(elLocationControllerWrapper);
    }
    if (!selectedLocationData.controllerData) {
        resetElLocationController();
        return;
    }
    // NOT using "ownerAddress" / "ownerName" from "crewDataByCrewId"
    const locationControllerInfo = {
        asteroid: {
            delegatedToAddress: null,
            delegatedToName: null,
        },
        building: {
            delegatedToAddress: null,
            delegatedToName: null,
        },
        lot: {
            delegatedToAddress: null,
            delegatedToName: null,
        },
        ship: {
            delegatedToAddress: null,
            delegatedToName: null,
        },
    };
    try {
        /**
         * NOTE: "crewDataByCrewId" may not yet contain any data for the crew IDs below, until the API response arrives.
         * In this case, "resetElLocationController" is triggered via "catch", until the crew data becomes available.
         */
        const buildingCrewId = selectedLocationData.controllerData.buildingCrewId;
        if (buildingCrewId) {
            locationControllerInfo.building.delegatedToAddress = crewDataByCrewId[buildingCrewId].delegatedToAddress;
            locationControllerInfo.building.delegatedToName = crewDataByCrewId[buildingCrewId].delegatedToName;
        }
        const shipCrewId = selectedLocationData.controllerData.shipCrewId;
        if (shipCrewId) {
            locationControllerInfo.ship.delegatedToAddress = crewDataByCrewId[shipCrewId].delegatedToAddress;
            locationControllerInfo.ship.delegatedToName = crewDataByCrewId[shipCrewId].delegatedToName;
        }
        const lotCrewId = selectedLocationData.controllerData.lotCrewId;
        if (lotCrewId) {
            locationControllerInfo.lot.delegatedToAddress = crewDataByCrewId[lotCrewId].delegatedToAddress;
            locationControllerInfo.lot.delegatedToName = crewDataByCrewId[lotCrewId].delegatedToName;
        }
        const asteroidCrewId = selectedLocationData.controllerData.asteroidCrewId;
        if (asteroidCrewId) {
            locationControllerInfo.asteroid.delegatedToAddress = crewDataByCrewId[asteroidCrewId].delegatedToAddress;
            locationControllerInfo.asteroid.delegatedToName = crewDataByCrewId[asteroidCrewId].delegatedToName;
        }
        let buildingControllerText = locationControllerInfo.building.delegatedToName;
        let buildingControllerTextIsCustom = false;
        let buildingControllerTextIsAddress = false;
        const buildingControllerTextIsBlacklisted = customBlacklistByAddress[locationControllerInfo.building.delegatedToAddress];
        let shipControllerText = locationControllerInfo.ship.delegatedToName;
        let shipControllerTextIsCustom = false;
        let shipControllerTextIsAddress = false;
        const shipControllerTextIsBlacklisted = customBlacklistByAddress[locationControllerInfo.ship.delegatedToAddress];
        let lotControllerText = locationControllerInfo.lot.delegatedToName;
        let lotControllerTextIsCustom = false;
        let lotControllerTextIsAddress = false;
        const lotControllerTextIsBlacklisted = customBlacklistByAddress[locationControllerInfo.lot.delegatedToAddress];
        let asteroidControllerText = locationControllerInfo.asteroid.delegatedToName;
        let asteroidControllerTextIsCustom = false;
        let asteroidControllerTextIsAddress = false;
        const asteroidControllerTextIsBlacklisted = customBlacklistByAddress[locationControllerInfo.asteroid.delegatedToAddress];
        // Prioritize custom label
        const buildingControllerAddress = locationControllerInfo.building.delegatedToAddress;
        if (customNameByAddress[buildingControllerAddress]) {
            buildingControllerText = customNameByAddress[buildingControllerAddress];
            buildingControllerTextIsCustom = true;
        }
        const shipControllerAddress = locationControllerInfo.ship.delegatedToAddress;
        if (customNameByAddress[shipControllerAddress]) {
            shipControllerText = customNameByAddress[shipControllerAddress];
            shipControllerTextIsCustom = true;
        }
        const lotControllerAddress = locationControllerInfo.lot.delegatedToAddress;
        if (customNameByAddress[lotControllerAddress]) {
            lotControllerText = customNameByAddress[lotControllerAddress];
            lotControllerTextIsCustom = true;
        }
        const asteroidControllerAddress = locationControllerInfo.asteroid.delegatedToAddress;
        if (customNameByAddress[asteroidControllerAddress]) {
            asteroidControllerText = customNameByAddress[asteroidControllerAddress];
            asteroidControllerTextIsCustom = true;
        }
        // Fallback to address
        if (!buildingControllerText) {
            buildingControllerText = locationControllerInfo.building.delegatedToAddress;
            buildingControllerTextIsAddress = true;
        }
        if (!shipControllerText) {
            shipControllerText = shipControllerAddress;
            shipControllerTextIsAddress = true;
        }
        if (!lotControllerText) {
            lotControllerText = lotControllerAddress;
            lotControllerTextIsAddress = true;
        }
        if (!asteroidControllerText) {
            asteroidControllerText = locationControllerInfo.asteroid.delegatedToAddress;
            asteroidControllerTextIsAddress = true;
        }
        setupElControllerItem('building', buildingControllerText, buildingControllerTextIsCustom, buildingControllerTextIsAddress, buildingControllerTextIsBlacklisted);
        setupElControllerItem('ship', shipControllerText, shipControllerTextIsCustom, shipControllerTextIsAddress, shipControllerTextIsBlacklisted);
        setupElControllerItem('lot', lotControllerText, lotControllerTextIsCustom, lotControllerTextIsAddress, lotControllerTextIsBlacklisted);
        setupElControllerItem('asteroid', asteroidControllerText, asteroidControllerTextIsCustom, asteroidControllerTextIsAddress, asteroidControllerTextIsBlacklisted);
        elLocationControllerWrapper.classList.remove('e115-hidden');
        // If both the building controller and ship controller are set => ship docked at spaceport
        elLocationControllerWrapper.classList.toggle('ship-view', buildingCrewId && shipCrewId);
        // If in system-view, only the asteroid controller will be shown
        elLocationControllerWrapper.classList.toggle('system-view', selectedLocationData.isSystemView);
    } catch (error) {
        resetElLocationController();
    }
}

/**
 * Supported values for "controllerType":
 * - "building"
 * - "ship"
 * - "lot"
 * - "asteroid"
 * - "crew"
 */
function setupElControllerItem(
    controllerType,
    controllerText,
    controllerTextIsCustom,
    controllerTextIsAddress,
    controllerTextIsBlacklisted = false,
    elControllerItem = null,
) {
    if (!elControllerItem && elLocationController) {
        // This function is being called for a location controller
        elControllerItem = elLocationController.querySelector(`.controller-${controllerType}`);
    }
    if (!elControllerItem) {
        return;
    }
    /**
     * If "controllerText" is an address, make it compact before displaying.
     * If "controllerText" is a name, display it as-is.
     * The flag "controllerTextIsAddress" is required instead of checking if "controllerText"
     * starts with "0x", becuase "controllerText" may be a name (not address) that starts with "0x".
     */
    const controllerTextCompact = controllerTextIsAddress ? getCompactAddress(controllerText) : controllerText;
    elControllerItem.textContent = controllerTextCompact; // empty "textContent" if this is null
    elControllerItem.dataset.controllerText = controllerText;
    elControllerItem.classList.toggle('is-custom', controllerTextIsCustom);
    elControllerItem.classList.toggle('is-address', controllerTextIsAddress);
    elControllerItem.classList.toggle('is-blacklisted', controllerTextIsBlacklisted);
    if (controllerTextIsAddress) {
        addTooltip(elControllerItem, 'Click to add a label for this address in the "Private Labels" widget');
    } else {
        removeTooltip(elControllerItem);
    }
    /**
     * Click on controller name or address => copy to clipboard + flash.
     * Using a dedicated handler "onClickElControllerItem", instead of using
     * an anonymous function, to avoid adding a new event listener during each cycle.
     */
    elControllerItem.addEventListener('click', onClickElControllerItem);
}

function onClickElControllerItem(event) {
    const elControllerItem = event.target;
    const controllerText = elControllerItem.dataset.controllerText;
    navigator.clipboard.writeText(controllerText);
    elControllerItem.classList.add('e115-flash-copy');
    // Stop flashing after 3 flashes (based on animation-duration of ".e115-flash-copy" in SCSS)
    setTimeout(() => elControllerItem.classList.remove('e115-flash-copy'), 600);
    if (elControllerItem.classList.contains('is-address')) {
        // Address without label => add it into the "Private Labels" widget
        toggleWidgets(true);
        selectWidget('Private Labels', {'add_address': controllerText});
    }
}

function resetElLocationController() {
    if (!elLocationController || !elLocationControllerWrapper || elLocationControllerWrapper.classList.contains('e115-hidden')) {
        return;
    }
    elLocationControllerWrapper.classList.add('e115-hidden');
    const elControllerBuilding = elLocationController.querySelector('.controller-building');
    const elControllerShip = elLocationController.querySelector('.controller-ship');
    const elControllerAsteroid = elLocationController.querySelector('.controller-asteroid');
    const elControllerLot = elLocationController.querySelector('.controller-lot');
    elControllerBuilding.textContent = '';
    elControllerShip.textContent = '';
    elControllerAsteroid.textContent = '';
    elControllerLot.textContent = '';
    elControllerBuilding.dataset.controllerText = '';
    elControllerShip.dataset.controllerText = '';
    elControllerAsteroid.dataset.controllerText = '';
    elControllerLot.dataset.controllerText = '';
}

function autoHideMarketsWithoutPrice() {
    const elMarketsFilters = document.getElementById('e115-markets-filters');
    if (!location.pathname.match(/^\/marketplace\/(\d+)\/all\/(\d+)/)) {
        // Product-specific markets window NOT open
        if (elMarketsFilters) {
            // Remove injected filters while navigating through other Marketplace pages
            elMarketsFilters.parentElement.removeChild(elMarketsFilters);
        }
        return;
    }
    const elsTable = document.querySelectorAll("table");
    if (elsTable.length !== 1) {
        // Maybe the game's DOM structure has changed?
        return;
    }
    const elMarketsTable = elsTable[0];
    elMarketsTable.querySelectorAll('tbody tr').forEach(elRow => {
        /**
         * Markets without any supply / demand have "—" for each of the
         * properties below, leading to their textContent containing "————"
         * - Supply
         * - Selling Price
         * - Demand
         * - Buying Price
         */
        if (elRow.textContent.replace(/\s/g, '').includes('————')) {
            elRow.classList.add('e115-no-prices');
        }
    });
    // Inject filter to hide markets with no prices, if not already injected
    if (!elMarketsFilters) {
        const elMarketsTitle = document.querySelector('h1');
        if (elMarketsTitle) {
            const elMarketsFilters = createEl('div', 'e115-markets-filters');
            injectFilterWithCheckbox(elMarketsFilters, 'Hide markets with no prices', 'autoHideMarketsWithoutPrice');
            // Additional handler to also update the toggle for this extension setting in the config panel
            elMarketsFilters.querySelector('input').addEventListener('input', onInputAutoHideMarketsWithoutPrice);
            // Inject the toggle next to the title
            elMarketsTitle.append(elMarketsFilters);
            elMarketsTitle.classList.add('e115-markets-title');
        }
    }
}

function onInputAutoHideMarketsWithoutPrice() {
    const isChecked = extensionSettings.autoHideMarketsWithoutPrice;
    // Sync the "checked" status of all toggles for this extension setting
    const elConfigPanel = document.getElementById('e115-config-panel-wrapper');
    if (elConfigPanel) {
        elConfigPanel.querySelector('input[name="auto-hide-markets-without-price"]').checked = isChecked;
    }
    const elMarketsFilters = document.getElementById('e115-markets-filters');
    if (elMarketsFilters) {
        elMarketsFilters.querySelector('input').checked = isChecked;
    }
}

/**
 * Auto-click the "Show Used Deposits" toggle, if it exists in the hud menu panel,
 * and if the associated checkbox is enabled (i.e. if the "svg" contains a "path").
 */
function autoHideUsedDeposits() {
    if (!extensionSettings.autoHideUsedDeposits) {
        return;
    }
    const elHudMenuPanel = getElHudMenuPanel();
    if (!elHudMenuPanel) {
        isOpenPanelWithUsedDeposits = false;
        return;
    }
    const reactPropsHudMenuPanel = getReactPropsForEl(elHudMenuPanel);
    if (!reactPropsHudMenuPanel || !reactPropsHudMenuPanel.open) {
        // The hud menu panel is closed
        isOpenPanelWithUsedDeposits = false;
        return;
    }
    // The hud menu panel is open
    const elShowUsedDeposits = findElWithMatchingTextNode(elHudMenuPanel, '*', 'Show Used Deposits');
    if (!elShowUsedDeposits) {
        // The panel does NOT contain "Show Used Deposits"
        isOpenPanelWithUsedDeposits = false;
        return;
    }
    // The panel contains "Show Used Deposits"
    if (isOpenPanelWithUsedDeposits) {
        /**
         * The panel containing "Show Used Deposits" was already open
         * in the previous cycle => NOT running this logic again.
         */
        return;
    }
    isOpenPanelWithUsedDeposits = true;
    if (elShowUsedDeposits.querySelector('path')) {
        // The "Show Used Deposits" toggle is enabled => auto-click to disable it
        elShowUsedDeposits.click();
    }
    try {
        /**
         * Try to expand the "My Deposits" panel, if collapsed.
         * Doing this here will NOT auto-expand it if there are NO unused deposits,
         * but this avoids introducing another flag, in addition to "isOpenPanelWithUsedDeposits".
         */
        const elMyDeposits = elShowUsedDeposits.parentElement.previousElementSibling;
        const reactFiberMyDeposits = getReactFiberForEl(elMyDeposits);
        const isCollapsedMyDeposits = reactFiberMyDeposits.return.memoizedProps.collapsed;
        if (isCollapsedMyDeposits) {
            elMyDeposits.click();
        }
    } catch (error) {
        // Swallow non-critical error
        return;
    }
}

/**
 * Auto-open the "Lot Inventory" panel, if a Warehouse is currently selected.
 * Auto-open the "Ship Inventory" panel, if a ship is currently selected.
 */
function autoOpenInventoryPanel() {
    if (!extensionSettings.autoOpenInventoryPanel) {
        return;
    }
    if (!extensionSettings.autoOpenInventoryPanelBypassOtherPanels) {
        // Do NOT bypass auto-opening the inventory, even if a hud menu panel is already open
        const elHudMenuPanel = getElHudMenuPanel();
        if (elHudMenuPanel) {
            const reactPropsHudMenuPanel = getReactPropsForEl(elHudMenuPanel);
            if (reactPropsHudMenuPanel && reactPropsHudMenuPanel.open) {
                // A hud menu panel is already open => do NOT auto-open the inventory
                return;
            }
        }
    }
    if (!selectedLocationData.idCurrent) {
        // NO valid location selected
        return;
    }
    if (selectedLocationData.idCurrent === selectedLocationData.idPrevious) {
        /**
         * Abort if SAME location was already selected in the previous cycle.
         * This ensures that, as long as this same location remains selected,
         * the inventory panel will NOT be auto-opened multiple times,
         * if the user manually closes it AFTER it was first auto-opened.
         */
        return;
    }
    if (isElHudMenuItemSelectedByLabel(hudMenuItemLabelLotInventory) || isElHudMenuItemSelectedByLabel(hudMenuItemLabelShipInventory)) {
        // The "Lot Inventory" or "Ship Inventory" hud menu item is already selected
        return;
    }
    /**
     * NEW valid location selected => OPEN the "Lot Inventory" or "Ship Inventory"
     * hud menu panel, via force-click on the respective hud menu item, if any.
     */
    const elHudMenuItemInventory = getElHudMenuItemByLabel(hudMenuItemLabelLotInventory) || getElHudMenuItemByLabel(hudMenuItemLabelShipInventory);
    if (!elHudMenuItemInventory) {
        return;
    }
    elHudMenuItemInventory.click();
}

/**
 * Auto-open the "Resources" panel, if an Extractor is currently selected
 */
function autoOpenResourcesPanel() {
    if (!extensionSettings.autoOpenResourcesPanel) {
        return;
    }
    if (!extensionSettings.autoOpenResourcesPanelBypassOtherPanels) {
        // Do NOT bypass auto-opening the Resources panel, even if a hud menu panel is already open
        const elHudMenuPanel = getElHudMenuPanel();
        if (elHudMenuPanel) {
            const reactPropsHudMenuPanel = getReactPropsForEl(elHudMenuPanel);
            if (reactPropsHudMenuPanel && reactPropsHudMenuPanel.open) {
                // A hud menu panel is already open => do NOT auto-open the Resources panel
                return;
            }
        }
    }
    if (selectedLocationData.buildingType !== BUILDING_TYPE.EXTRACTOR) {
        // NO extractor selected
        return;
    }
    if (selectedLocationData.idCurrent === selectedLocationData.idPrevious) {
        /**
         * Abort if SAME location was already selected in the previous cycle.
         * This ensures that, as long as this same location remains selected,
         * the Resources panel will NOT be auto-opened multiple times,
         * if the user manually closes it AFTER it was first auto-opened.
         */
        return;
    }
    if (isElHudMenuItemSelectedByLabel(hudMenuItemLabelResources)) {
        // The "Resources" hud menu item is already selected
        return;
    }
    /**
     * NEW extractor selected => OPEN the "Resources" hud menu panel,
     * via force-click on the respective hud menu item, if any.
     */
    const elHudMenuItemResources = getElHudMenuItemByLabel(hudMenuItemLabelResources);
    if (!elHudMenuItemResources) {
        return;
    }
    elHudMenuItemResources.click();
}

/**
 * NOTE: Most of the logic in this function is responsibe for
 * generating data for each inventory, which is also required
 * for the filters injected via "injectInventoriesFilters".
 * The actual highlighting of blacklisted inventories
 * is only done at the very end of this function.
 */
async function highlightBlocklistedInventories() {
    const elAvailableInventoriesTitle = findElWithMatchingTextNode(document.body, '*', 'Available Inventories');
    if (!elAvailableInventoriesTitle) {
        return;
    }
    const elAvailableInventoriesTable = elAvailableInventoriesTitle.parentElement.parentElement.querySelector('table');
    if (!elAvailableInventoriesTable) {
        return;
    }
    const reactFiberInventories = getReactFiberForEl(elAvailableInventoriesTable);
    if (!reactFiberInventories || !reactFiberInventories.memoizedProps) {
        return;
    }
    // Parse React data for inventories
    let buildingIds = [];
    let shipIds = [];
    let inventoryReactDataByName = {};
    try {
        const reactChildrenInventories = reactFiberInventories.memoizedProps.children[1].props.children;
        reactChildrenInventories.forEach(reactChildInventory => {
            const keyData = JSON.parse(reactChildInventory.key);
            const inventoryId = keyData.id.toString();
            const inventoryName = reactChildInventory.props.row.name;
            const inventoryLabel = keyData.label;
            const inventoryType = reactChildInventory.props.row.type;
            inventoryReactDataByName[inventoryName] = {
                inventoryId,
                inventoryLabel,
                inventoryType,
            };
            switch (inventoryLabel) {
                case ENTITY_IDS.BUILDING:
                    if (!buildingIds.includes(inventoryId)) {
                        // Ensure UNIQUE building IDs
                        buildingIds.push(inventoryId);
                    }
                    break;
                case ENTITY_IDS.SHIP:
                    if (!shipIds.includes(inventoryId)) {
                        // Ensure UNIQUE ship IDs
                        shipIds.push(inventoryId);
                    }
                    break;
            }
        });
    } catch (error) {
        // Swallow this error
    }
    // Prepare inventories in the DOM
    const elAvailableInventoriesRows = elAvailableInventoriesTable.querySelectorAll('tbody tr');
    elAvailableInventoriesRows.forEach(elRow => {
        // This is a ONE-TIME operation per row
        if (elRow.classList.contains('e115-prepared')) {
            return;
        }
        elRow.classList.add('e115-prepared');
        const elRowCells = elRow.querySelectorAll('td');
        const inventoryName = elRowCells[1].textContent.trim();
        const inventoryReactData = inventoryReactDataByName[inventoryName];
        if (!inventoryReactData) {
            /**
             * This may happen if the user enables "Public Inventories"
             * AFTER the non-public inventories were already parsed
             * and saved into "inventoryReactDataByName".
             */
            return;
        }
        /**
         * NOTE: Each ship name appears twice in "elAvailableInventoriesRows"
         * (cargo + propellant), but they have the same inventory ID.
         */
        elRow.dataset.e115InventoryId = inventoryReactData.inventoryId;
        elRow.dataset.e115InventoryLabel = inventoryReactData.inventoryLabel;
        elRow.dataset.e115InventoryType = inventoryReactData.inventoryType;
        // Self inventory if the first cell contains an SVG ("star" icon)
        // elRow.dataset.e115InventorySelf = Boolean(elRowCells[0].querySelector('svg')); // NOT used yet
    });
    await updateInventoriesDataByLabelAndIdsIfNotSet(ENTITY_IDS.BUILDING, buildingIds);
    await updateInventoriesDataByLabelAndIdsIfNotSet(ENTITY_IDS.SHIP, shipIds);
    /**
     * At this point, the data for all inventories should be cached,
     * except when waiting for the initial API calls to inventories-data.
     */
    elAvailableInventoriesRows.forEach(elRow => {
        const inventoryId = elRow.dataset.e115InventoryId;
        if (!inventoryId) {
            /**
             * This may happen if the user enables "Public Inventories"
             * AFTER the non-public inventories were already parsed
             * and saved into "inventoryReactDataByName".
             */
            return;
        }
        const inventoryLabel = elRow.dataset.e115InventoryLabel;
        const inventoryType = elRow.dataset.e115InventoryType;
        const inventoryData = inventoriesDataByLabelAndId[inventoryLabel][inventoryId];
        if (!inventoryData) {
            // Waiting for the initial API calls to inventories-data
            return;
        }
        const controllerAddress = inventoryData.controllerCrewData.delegatedToAddress;
        // Set "data-e115-inventory-controlled-by-me"
        elRow.dataset.e115InventoryControlledByMe = controllerAddress === getCurrentWalletAddress().toLowerCase();
        // Set "data-e115-inventory-is-warehouse"
        elRow.dataset.e115InventoryIsWarehouse = inventoryType === 'Warehouse';
        if (extensionSettings.highlightBlocklistedInventories && customBlacklistByAddress[controllerAddress]) {
            // Blacklisted controller
            elRow.classList.add('e115-blacklisted-inventory');
        }
    });
}

/**
 * Highlight crews which are rationing, from among:
 * - selected crew (top-left)
 * - "My Crews" hud menu panel
 */
function highlightCrewsRationing() {
    const isEnabledHighlight = extensionSettings.highlightCrewsRationing;
    // Highlight selected crew if rationing
    if (selectedCrewData.rationing !== null) {
        const elSelectedCrewPanel = getElSelectedCrewPanel();
        if (elSelectedCrewPanel) {
            const shouldHighlight = selectedCrewData.rationing < 1 && isEnabledHighlight;
            elSelectedCrewPanel.classList.toggle('e115-crew-rationing', shouldHighlight);
        }
    }
    // Highlight "My Crews" which are rationing
    const elsCrews = getElsMyCrews();
    elsCrews.forEach(elCrew => {
        const reactFiberCrew = getReactFiberForEl(elCrew);
        if (!reactFiberCrew || !reactFiberCrew.memoizedProps) {
            return;
        }
        const reactChildren = reactFiberCrew.memoizedProps.children;
        const crewData = getReactPropDataFromChildrenRecursive('crew', reactChildren);
        try {
            const crewRationing = crewData.propValue._foodBonuses.rationing;
            if (crewRationing < 1) {
                const shouldHighlight = crewRationing < 1 && isEnabledHighlight;
                elCrew.classList.toggle('e115-my-crew-rationing', shouldHighlight);
            }
            const crewConsumption = crewData.propValue._foodBonuses.consumption;
            const crewLastFed = crewData.propValue.Crew.lastFed;
            const crewTimeSinceFed = ((new Date().getTime()) / 1000 - crewLastFed) * 24;
            const crewFoodRatio = Math.round(getCurrentFoodRatio(parseInt(crewTimeSinceFed), crewConsumption) * 100);
            elCrew.dataset.e115CrewFoodRatio = `${crewFoodRatio}%`;
        } catch (error) {
            // Swallow this error
        }
    });
}

function showShipStatsForMyCrews() {
    const elsCrews = getElsMyCrews();
    elsCrews.forEach(elCrew => {
        if (!extensionSettings.showShipStatsForMyCrews) {
            delete elCrew.dataset.e115ShipLoadedPropellantPercent;
            return;
        }
        const reactFiberCrew = getReactFiberForEl(elCrew);
        if (!reactFiberCrew || !reactFiberCrew.memoizedProps) {
            return;
        }
        const reactChildren = reactFiberCrew.memoizedProps.children;
        const crewData = getReactPropDataFromChildrenRecursive('crew', reactChildren);
        try {
            const crewLocationData = crewData.propValue.Location.location;
            if (crewLocationData.label !== ENTITY_IDS.SHIP) {
                // Crew NOT in a ship
                return;
            }
            const shipId = crewLocationData.id;
            updateShipDataByShipIdIfNotSet(shipId);
            const shipData = shipDataByShipId[shipId];
            if (!shipData) {
                return;
            }
            elCrew.dataset.e115ShipLoadedPropellantPercent = `${Math.round(shipData.shipLoadedPropellantPercent)}%`;
        } catch (error) {
            // Swallow this error
        }
    });
}

/**
 * Inject various features into the DOM periodically, as needed
 */
function injectFeaturesPeriodically() {
    setInterval(() => {
        /**
         * The crew data must be updated BEFORE calling other functions which rely on "selectedCrewData":
         * - "highlightCrewsRationing"
         */
        updateCrewData();
        /**
         * The location data must be updated BEFORE calling other functions which rely on "selectedLocationData":
         * - "injectIndustryBuilderButton"
         * - "injectLocationController"
         * - "autoOpenInventoryPanel"
         * - "autoOpenResourcesPanel"
         */
        updateLocationData();
        injectWidgets();
        injectCaptainVideo();
        injectCrewController();
        injectInventoriesFilters();
        injectProcessFilter();
        injectMyOrdersProductLinks();
        injectAndApplyExtractionPercent();
        injectIndustryBuilderButton();
        injectLocationController();
        autoHideMarketsWithoutPrice();
        autoHideUsedDeposits();
        autoOpenInventoryPanel();
        autoOpenResourcesPanel();
        highlightBlocklistedInventories();
        highlightCrewsRationing();
        showShipStatsForMyCrews();
        updateMarketValueOfSelectedItems();
    }, 1000);
}

/**
 * Periodically update prices via API call
 */
function updatePricesPeriodically() {
    updatePrices()
    setInterval(updatePrices, 10 * MINUTE_IN_MILLISECONDS);
}

/**
 * Handle messages e.g. from widgets iframe
 */
function handleMessage(event) {
    if (!event.data.widgetEventKey || !event.data.widgetEventValue) {
        // Not a valid message from the widgets iframe
        return;
    }
    switch (event.data.widgetEventKey) {
        case 'SHOPPING_LIST_CLICKED_PRODUCT_NAME':
            searchMarketplace(event.data.widgetEventValue);
            break;
        case 'PRIVATE_LABELS_UPDATED':
            // Save private labels from widget, into local-storage
            customNameByAddress = JSON.parse(event.data.widgetEventValue);
            // Handle new JSON format
            Object.keys(customNameByAddress).forEach(address => {
                const addressData = customNameByAddress[address];
                if (typeof addressData !== 'string') {
                    // New "addressData" format
                    customBlacklistByAddress[address] = addressData.isBlacklisted;
                    customNameByAddress[address] = addressData.label;
                }
            });
            localStorage.setItem('e115CustomBlacklistByAddress', JSON.stringify(customBlacklistByAddress));
            localStorage.setItem('e115CustomNameByAddress', JSON.stringify(customNameByAddress));
            break;
    }
}

function onClickConfigTitle() {
    // Show / hide the extension-config options
    document.getElementById('e115-config-panel-wrapper').classList.toggle('active');
}

function onInputCrewmateColorIntensity(el) {
    setExtensionSetting('crewmateColorIntensity', parseInt(el.value));
    document.querySelector(':root').style.setProperty('--crewmate-color-intensity', extensionSettings.crewmateColorIntensity);
}

function onClickConfigOption(el) {
    switch (el.name) {
        case 'auto-hide-markets-without-price':
            setExtensionSetting('autoHideMarketsWithoutPrice', el.checked);
            document.body.dataset.autoHideMarketsWithoutPrice = el.checked;
            onInputAutoHideMarketsWithoutPrice();
            break;
        case 'auto-hide-used-deposits':
            setExtensionSetting('autoHideUsedDeposits', el.checked);
            break;
        case 'auto-open-inventory-panel':
            setExtensionSetting('autoOpenInventoryPanel', el.checked);
            break;
        case 'auto-open-inventory-panel-bypass-other-panels':
            setExtensionSetting('autoOpenInventoryPanelBypassOtherPanels', el.checked);
            break;
        case 'auto-open-resources-panel':
            setExtensionSetting('autoOpenResourcesPanel', el.checked);
            break;
        case 'auto-open-resources-panel-bypass-other-panels':
            setExtensionSetting('autoOpenResourcesPanelBypassOtherPanels', el.checked);
            break;
        case 'highlight-blocklisted-inventories':
            setExtensionSetting('highlightBlocklistedInventories', el.checked);
            break;
        case 'highlight-crews-rationing':
            setExtensionSetting('highlightCrewsRationing', el.checked);
            break;
        case 'industry-builder-button':
            setExtensionSetting('industryBuilderButton', el.checked);
            break;
        case 'inventory-item-names':
            setExtensionSetting('inventoryItemNames', el.checked);
            document.body.dataset.inventoryItemNames = el.checked;
            break;
        case 'location-controller':
            setExtensionSetting('locationController', el.checked);
            break;
        case 'show-ship-stats-for-my-crews':
            setExtensionSetting('showShipStatsForMyCrews', el.checked);
            break;
    }
}

// Source: https://gist.github.com/Machy8/1b0e3cd6c61f140a6b520269acdd645f
function on(eventType, selector, callback) {
    document.addEventListener(eventType, event => {
        if (event.target.matches === undefined) {
            // Avoid errors in Brave
            return;
        }
        // Parse target and its ancestors, until a matching selector is found
        let el = event.target;
        while (el) {
            if (el.matches(selector)) {
                callback(el);
                break;
            } else {
                el = el.parentElement; // null after parsing the "html" element
            }
        }
    }, true); // "true" required for correct behaviour of e.g. "mouseenter" / "mouseleave" attached to elements that have children
}
